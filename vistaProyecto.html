<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vista de Proyecto - PDT: G&N CE</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <style>
        /* Estilos copiados de intro.html para consistencia visual */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 10px; }
        .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); overflow: hidden; }
        .header { background: linear-gradient(135deg, #2c3e50, #3498db); color: white; padding: 30px; text-align: center; }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; }
        .header p { font-size: 1.2rem; opacity: 0.9; }
        .company-logo { display: flex; justify-content: center; margin-bottom: 20px; }
        .company-logo img { filter: drop-shadow(0 4px 8px rgba(0,0,0,0.2)); }
        .progress-summary { margin-top: 20px; padding: 20px; background: rgba(255,255,255,0.1); border-radius: 15px; }
        .progress-bar-container { background: rgba(255,255,255,0.2); height: 20px; border-radius: 10px; overflow: hidden; margin: 10px 0; }
        .progress-bar-fill { height: 100%; background: linear-gradient(90deg, #27ae60, #2ecc71); width: 0%; transition: width 1s ease-out; border-radius: 10px; position: relative; }
        #progress-text { position: absolute; right: 10px; top: 50%; transform: translateY(-50%); color: rgba(255,255,255,0.9); font-weight: bold; font-size: 16px; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
        .progress-text { font-size: 1.1rem; font-weight: bold; margin-bottom: 5px; }
        .progress-stats { display: flex; justify-content: space-around; margin-top: 15px; font-size: 0.9rem; }
        .stat-item { text-align: center; }
        .stat-number { font-size: 1.5rem; font-weight: bold; display: block; }
        .timeline-container { padding: 40px; }
        .phases-container { position: relative; }
        .phase { margin-bottom: 40px; }
        .phase-header { display: flex; align-items: center; margin-bottom: 20px; padding: 15px 20px; border-radius: 15px; font-weight: bold; font-size: 1.3rem; color: white; cursor: pointer; }
        .phase-header.phase1 { background: linear-gradient(135deg, #e74c3c, #c0392b); }
        .phase-header.phase2 { background: linear-gradient(135deg, #3498db, #2980b9); }
        .phase-header.phase3 { background: linear-gradient(135deg, #f39c12, #e67e22); }
        .phase-header.phase4 { background: linear-gradient(135deg, #27ae60, #229954); }
        .phase-header.phase-default { background: linear-gradient(135deg, #95a5a6, #7f8c8d); }
        .phase-number { width: 40px; height: 40px; border-radius: 50%; background: rgba(255,255,255,0.2); display: flex; align-items: center; justify-content: center; margin-right: 15px; font-size: 1.2rem; }
        .phase-title { flex: 1; }
        .phase-toggle { font-size: 1.2rem; transition: transform 0.3s ease; }
        .phase-header.collapsed .phase-toggle { transform: rotate(-90deg); }
        .tasks-timeline { padding-left: 20px; transition: all 0.3s ease; }
        .phase.collapsed .tasks-timeline { display: none; }
        .tasks-legend { margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 15px; border: 1px solid #dee2e6; }
        .tasks-legend h3 { margin-bottom: 15px; color: #2c3e50; text-align: center; }
        .legend-items { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
        .legend-item { display: flex; align-items: center; gap: 10px; }
        .legend-color { width: 30px; height: 20px; border-radius: 5px; }
        .legend-color.milestone { border-left: 4px solid #e74c3c; }
        .legend-color.completed { border-left: 4px solid #28a745; }
        .legend-symbol { font-size: 0.8rem; color: #34495e; background: #e9ecef; padding: 2px 6px; border-radius: 3px; }
        .task-hours-example { background: #95a5a6; color: white; padding: 2px 8px; border-radius: 12px; font-weight: bold; font-size: 0.7rem; }
        .task-dates-example { font-size: 0.7rem; color: #34495e; }
        .tasks-timeline { padding-left: 20px; }
        .task { position: relative; margin-bottom: 15px; padding: 12px 20px; background: #f8f9fa; border-radius: 10px; border-left: 4px solid #bdc3c7; }
        .task.milestone { border-left-color: #e74c3c; background: linear-gradient(135deg, #fff5f5, #ffeaea); }
        .task.completed {
            background: linear-gradient(135deg, #d5f4e6, #c8e6c9);
            border-left-color: #27ae60;
            opacity: 0.9;
        }
        .task.completed .task-name {
            text-decoration: line-through;
            color: #27ae60;
        }
        .task-content { display: flex; justify-content: space-between; align-items: flex-start; gap: 20px; }
        .task-left { display: flex; align-items: center; gap: 10px; flex: 1; min-width: 0; }
        .task-right { display: flex; flex-direction: row; align-items: center; gap: 15px; flex-shrink: 0; }
        .task-name { font-weight: 500; color: #2c3e50; }
        .task-details { display: flex; align-items: center; gap: 15px; font-size: 0.85rem; flex-wrap: wrap; }
        .task-hours { background: #95a5a6; color: white; padding: 2px 8px; border-radius: 12px; font-weight: bold; white-space: nowrap; min-width: 40px; text-align: center; }
        .task-dates { font-size: 0.8rem; color: #34495e; white-space: nowrap; }
        .task-times { display: flex; gap: 15px; margin-top: 0; font-size: 0.8rem; flex-wrap: wrap; }
        .task-time-label { display: flex; align-items: center; gap: 5px; color: #2c3e50; font-weight: 500; }
        .task-start-time-display, .task-end-time-display { background: #f8f9fa; padding: 2px 6px; border-radius: 4px; border: 1px solid #dee2e6; font-family: monospace; font-weight: bold; color: #495057; }
        .project-dates-interactive { padding: 20px; background: #f0f2f5; border-radius: 15px; margin-bottom: 30px; }
        .project-dates-interactive h3 { margin-bottom: 15px; color: #2c3e50; }
        .date-controls { display: flex; gap: 10px; align-items: center; margin-bottom: 15px; }
        .date-controls input { padding: 8px; border: 1px solid #ccc; border-radius: 5px; }
        .date-controls button { padding: 8px 15px; background-color: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; }
        .date-info { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-top: 20px; }
        .date-info p { background: #e9ecef; padding: 10px; border-radius: 5px; }
        .project-config { margin-top: 0; padding: 15px; background: white; border-radius: 10px; border: 1px solid #dee2e6; }
        .config-section { display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 15px; }
        .config-item { display: flex; align-items: center; gap: 10px; min-height: 40px; padding: 8px 0; }
        .config-item label { font-weight: 500; color: #2c3e50; min-width: 280px; }
        .config-item input[type="checkbox"] { width: 18px; height: 18px; }
        .config-item input[type="date"] { padding: 6px; border: 1px solid #ccc; border-radius: 4px; flex: 1; max-width: 200px; }
        .config-item input[type="time"] { padding: 6px; border: 1px solid #ccc; border-radius: 4px; flex: 1; max-width: 200px; }
        .config-item input[type="number"] { padding: 6px; border: 1px solid #ccc; border-radius: 4px; flex: 1; max-width: 200px; }
        .config-buttons { display: flex; gap: 10px; margin-top: 15px; }
        .config-buttons button { padding: 8px 15px; background-color: #27ae60; color: white; border: none; border-radius: 5px; cursor: pointer; }
        .holidays-list { margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px; }
        .holidays-list h4 { margin-bottom: 10px; color: #2c3e50; }
        #holidays-container { margin-bottom: 10px; }
        .holiday-item { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; flex-wrap: wrap; }
        .holiday-item input { padding: 4px; border: 1px solid #ccc; border-radius: 3px; flex: 1; min-width: 120px; }
        .holiday-item button { padding: 2px 8px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px; flex-shrink: 0; }
        #add-holiday-btn { padding: 6px 12px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .s-curve-metrics { display: flex; gap: 20px; margin-top: 30px; justify-content: center; }
        .metric-card { background: white; padding: 20px; border-radius: 15px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.1); min-width: 150px; transition: transform 0.3s ease; }
        .metric-card:hover { transform: translateY(-5px); }
        .metric-value { font-size: 1.8rem; font-weight: bold; color: #2c3e50; margin-bottom: 5px; }
        .metric-label { font-size: 0.9rem; color: #7f8c8d; font-weight: 500; }
        .metric-card:nth-child(1) .metric-value { color: #3498db; }
        .metric-card:nth-child(2) .metric-value { color: #f39c12; }
        .metric-card:nth-child(3) .metric-value { color: #27ae60; }
        .s-curve-section, .calendar-section { margin-top: 40px; padding: 30px; background: linear-gradient(135deg, #f8f9fa, #e9ecef); border-radius: 20px; border-top: 4px solid #9b59b6; }
        .calendar-timeline { position: relative; }
        .timeline-header { margin-bottom: 20px; }
        .timeline-dates { display: flex; justify-content: space-between; font-weight: bold; color: #2c3e50; }
        .timeline-body { position: relative; height: 400px; border-left: 2px solid #bdc3c7; padding-left: 20px; }
        .timeline-phase { margin-bottom: 30px; }
        .phase-label { font-weight: bold; margin-bottom: 10px; color: #2c3e50; }
        .phase-bar-container { position: relative; height: 40px; margin-bottom: 20px; }
        .phase-bar { position: absolute; height: 30px; border-radius: 15px; top: 0; opacity: 0.7; }
        .phase-bar.phase1 { background: linear-gradient(135deg, #e74c3c, #c0392b); }
        .phase-bar.phase2 { background: linear-gradient(135deg, #3498db, #2980b9); }
        .phase-bar.phase3 { background: linear-gradient(135deg, #f39c12, #e67e22); }
        .phase-bar.phase4 { background: linear-gradient(135deg, #27ae60, #229954); }
        .task-bar { position: absolute; height: 20px; background: #95a5a6; border-radius: 10px; top: 35px; border: 2px solid #7f8c8d; overflow: hidden; }
        .task-bar.completed { background: #27ae60; border-color: #229954; }
        .task-bar-label { font-size: 0.7rem; color: white; padding: 2px 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .calendar-section { margin-top: 40px; padding: 30px; background: linear-gradient(135deg, #f8f9fa, #e9ecef); border-radius: 20px; border-top: 4px solid #9b59b6; }
        .calendar-header { text-align: center; margin-bottom: 30px; }
        .calendar-header h2 { color: #2c3e50; font-size: 1.8rem; margin-bottom: 10px; }
        .calendar-header p { color: #7f8c8d; font-size: 1rem; }
        .semester-calendar { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 30px; max-width: 100%; overflow: hidden; }
        .month-container { background: white; border-radius: 15px; padding: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); transition: transform 0.3s ease; max-width: 100%; min-width: 0; overflow: hidden; }
        .month-container:hover { transform: translateY(-3px); }
        .month-header { text-align: center; font-size: 1.3rem; font-weight: bold; color: #2c3e50; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #ecf0f1; }
        .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 1px; width: 100%; max-width: 100%; }
        .calendar-day-header { text-align: center; font-weight: bold; color: #7f8c8d; padding: 6px 2px; font-size: 0.75rem; background: #f8f9fa; border-radius: 3px; min-height: 20px; display: flex; align-items: center; justify-content: center; }
        .calendar-day { 
            width: 100%; 
            aspect-ratio: 1; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-start; 
            border-radius: 4px; 
            font-size: 0.8rem; 
            font-weight: 500; 
            color: #2c3e50; 
            background: #fff; 
            border: 1px solid #ecf0f1; 
            position: relative; 
            cursor: pointer; 
            transition: all 0.3s ease; 
            padding: 2px; 
            overflow: hidden; 
            box-sizing: border-box;
        }
        .calendar-day:hover { 
            background: #f0f8ff; 
            transform: scale(1.05); 
        }
        .calendar-day.other-month { 
            color: #bdc3c7; 
            background: #f8f9fa; 
        }
        .calendar-day.has-task { 
            background: linear-gradient(135deg, #e8f5e8, #d4edda); 
            border-color: #27ae60; 
            font-weight: bold; 
        }
        .calendar-day.has-milestone { 
            background: linear-gradient(135deg, #fff3cd, #ffeaa7); 
            border-color: #f39c12; 
            font-weight: bold; 
        }
        .calendar-day.has-task.has-milestone { 
            background: linear-gradient(135deg, #fff3cd, #e8f5e8, #ffeaa7); 
            border: 2px solid #f39c12; 
            box-shadow: 0 2px 8px rgba(243, 156, 18, 0.3); 
        }
        .calendar-day.has-completed-task { 
            background: linear-gradient(135deg, #d4edda, #c3e6cb) !important; 
            border: 2px solid #28a745 !important; 
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.4) !important; 
            font-weight: bold; 
        }
        .calendar-day.holiday { 
            background: linear-gradient(135deg, #f8d7da, #f5c6cb); 
            border: 2px solid #dc3545; 
            color: #721c24; 
            font-weight: bold; 
        }
        .holiday-name {
            font-size: 0.6rem;
            font-weight: bold;
            color: #721c24;
            margin-top: 1px;
            line-height: 1;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        .day-number { 
            font-weight: bold; 
            margin-bottom: 1px; 
            align-self: flex-start;
        }
        .calendar-day .task-indicator, 
        .calendar-day .milestone-indicator {
            margin: 1px;
        }
        .calendar-day {
            flex-wrap: wrap;
            justify-content: center;
            min-height: 45px;
            padding: 2px;
        }
        .task-indicator { 
            background: #3498db; 
            color: white; 
            border-radius: 50%; 
            width: 20px; 
            height: 20px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 0.7rem; 
            font-weight: bold; 
            margin: 1px; 
            animation: bounce 0.5s ease-out; 
            flex-shrink: 0; 
            cursor: pointer; 
            position: relative; 
            transition: all 0.2s ease;
        }
        .milestone-indicator { 
            background: #e74c3c; 
            color: white; 
            border-radius: 50%; 
            width: 20px; 
            height: 20px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 0.7rem; 
            font-weight: bold; 
            margin: 1px; 
            animation: pulse 2s infinite; 
            flex-shrink: 0; 
            cursor: pointer; 
            position: relative; 
            transition: all 0.2s ease;
        }
        
        /* Tooltip personalizado */
        .calendar-tooltip { 
            position: fixed; 
            background: rgba(0,0,0,0.9); 
            color: white; 
            padding: 8px 12px; 
            border-radius: 6px; 
            font-size: 14px; 
            font-weight: 500;
            z-index: 10000; 
            pointer-events: none; 
            opacity: 1; 
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 300px;
            word-wrap: break-word;
        }
        
        /* Modal para tareas del d√≠a */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        .modal-overlay.show { opacity: 1; visibility: visible; }
        .modal-content { 
            background: white; 
            border-radius: 15px; 
            padding: 25px; 
            max-width: 500px; 
            max-height: 70vh; 
            overflow-y: auto; 
            box-shadow: 0 20px 40px rgba(0,0,0,0.3); 
            transform: scale(0.9); 
            transition: transform 0.3s ease; 
        }
        .modal-overlay.show .modal-content { transform: scale(1); }
        .modal-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 20px; 
            padding-bottom: 15px; 
            border-bottom: 2px solid #ecf0f1; 
        }
        .modal-header h3 { 
            font-size: 1.5rem; 
            font-weight: bold; 
            color: #2c3e50; 
            margin: 0; 
        }
        .close-modal-btn { 
            background: none; 
            border: none; 
            font-size: 1.5rem; 
            cursor: pointer; 
            color: #7f8c8d; 
            padding: 5px; 
            border-radius: 50%; 
            transition: all 0.3s ease; 
        }
        .close-modal-btn:hover { background: #f8f9fa; color: #2c3e50; }
        .modal-tasks-list { max-height: 50vh; overflow-y: auto; }
        .modal-task-item { 
            display: flex; 
            align-items: center; 
            gap: 15px; 
            padding: 15px; 
            margin-bottom: 10px; 
            background: #f8f9fa; 
            border-radius: 10px; 
            border-left: 4px solid #bdc3c7; 
            cursor: pointer; 
            transition: all 0.3s ease; 
        }
        .modal-task-item:hover { 
            background: #e9ecef; 
            transform: translateX(5px); 
            box-shadow: 0 5px 15px rgba(0,0,0,0.1); 
        }
        .modal-task-item.completed { 
            background: linear-gradient(135deg, #d5f4e6, #c8e6c9); 
            border-left-color: #27ae60; 
        }
        .modal-task-item.milestone { 
            background: linear-gradient(135deg, #fff5f5, #ffeaea); 
            border-left-color: #e74c3c; 
        }
        .modal-task-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .modal-task-number {
            font-size: 1.2rem;
            font-weight: bold;
            color: #2c3e50;
        }
        .modal-task-status {
            font-size: 0.8rem;
            color: #7f8c8d;
        }
        .modal-task-info { flex: 1; }
        .modal-task-name { 
            font-weight: 600; 
            color: #2c3e50; 
            margin-bottom: 5px; 
        }
        .modal-task-details { 
            font-size: 0.85rem; 
            color: #7f8c8d;
            display: flex;
            justify-content: space-between;
        }
        .modal-task-times {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e9ecef;
        }
        .modal-task-time-start,
        .modal-task-time-end {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
        }
        .modal-task-time-label {
            font-weight: 600;
            color: #2c3e50;
            min-width: 45px;
        }
        .modal-task-time-value {
            color: #34495e;
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.75rem;
        }
        
        /* Animaci√≥n de resaltado para tareas */
        .task-highlight {
            animation: highlight 3s ease-out;
            border: 3px solid #3498db !important;
            background: linear-gradient(135deg, #e3f2fd, #bbdefb) !important;
            transform: scale(1.02);
            box-shadow: 0 0 25px rgba(52, 152, 219, 0.8) !important;
            position: relative;
            z-index: 10;
        }
        .task-highlight::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #3498db, #5dade2, #85c1e9, #3498db);
            background-size: 400% 400%;
            animation: borderGlow 2s ease-in-out infinite;
            border-radius: 12px;
            z-index: -1;
        }
        @keyframes highlight {
            0% {
                border-color: #3498db;
                background: linear-gradient(135deg, #e3f2fd, #bbdefb);
                transform: scale(1.02);
                box-shadow: 0 0 25px rgba(52, 152, 219, 0.8);
            }
            50% {
                border-color: #2980b9;
                background: linear-gradient(135deg, #bbdefb, #90caf9);
                transform: scale(1.05);
                box-shadow: 0 0 35px rgba(52, 152, 219, 1);
            }
            100% {
                border-color: #bdc3c7;
                background: inherit;
                transform: scale(1);
                box-shadow: none;
            }
        }
        @keyframes borderGlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .calendar-legend { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 20px; margin-top: 20px; padding: 25px; background: white; border-radius: 15px; box-shadow: 0 3px 10px rgba(0,0,0,0.1); justify-items: start; align-items: center; }
        .legend-calendar-item { display: flex; align-items: center; gap: 10px; font-weight: 500; color: #2c3e50; min-width: 200px; justify-content: flex-start; }
        .legend-calendar-color { width: 20px; height: 20px; border-radius: 4px; }
        .legend-task-start { background: linear-gradient(135deg, #e8f5e8, #d4edda); border: 2px solid #27ae60; }
        .legend-milestone-start { background: linear-gradient(135deg, #fff3cd, #ffeaa7); border: 2px solid #f39c12; }
        @keyframes bounce { 0%, 20%, 50%, 80%, 100% { transform: translateY(0); } 40% { transform: translateY(-5px); } 60% { transform: translateY(-3px); } }
        @media (max-width: 768px) { 
            .calendar-day { 
                min-height: 40px; 
                max-height: 45px; 
                font-size: 0.75rem; 
                padding: 1px;
            } 
            .calendar-day-header { 
                font-size: 0.7rem; 
                padding: 4px 1px; 
                min-height: 18px; 
            } 
            .task-indicator, 
            .milestone-indicator { 
                width: 16px; 
                height: 16px; 
                font-size: 0.6rem; 
                margin: 0.5px;
            } 
            .calendar-legend { 
                grid-template-columns: 1fr; 
                gap: 15px; 
                padding: 20px; 
            } 
            .legend-calendar-item { 
                min-width: auto; 
                justify-content: flex-start; 
            } 
        }
        @media (max-width: 1200px) { .semester-calendar { grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; } }
        #download-pdf { margin: 20px 10px; display: inline-block; padding: 10px 20px; background-color: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem; }
        #back-to-projects-btn { margin: 20px 10px; padding: 10px 20px; background-color: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem; }
        #logout-btn { margin: 20px 10px; padding: 10px 20px; background-color: #95a5a6; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem; }

        /* Estilos para el bot√≥n flotante de navegaci√≥n */
        #floatingNavBtn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 9999;
            background: linear-gradient(135deg, #3498db, #764ba2);
            color: white;
            border-radius: 50px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            padding: 18px 22px;
            cursor: pointer;
            font-size: 2rem;
            transition: background 0.3s;
        }
        #floatingNavBtn:hover {
            background: linear-gradient(135deg, #764ba2, #3498db);
        }
        #floatingNavMenu {
            display: none;
            position: absolute;
            bottom: 60px;
            right: 0;
            background: white;
            color: #2c3e50;
            border-radius: 15px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            padding: 8px 0;
            min-width: 160px;
            flex-direction: column;
            gap: 0;
        }
        #floatingNavMenu a {
            display: block;
            padding: 6px 12px;
            color: #2c3e50;
            text-decoration: none;
            font-weight: 400;
            font-size: 13px;
            border-bottom: 1px solid #eee;
            transition: background 0.2s, color 0.2s;
        }
        #floatingNavMenu a:last-child {
            border-bottom: none;
        }
        #floatingNavMenu a:hover {
            background: #f0f8ff;
            color: #3498db;
        }

        /* Estilos para botones de acci√≥n con ancho uniforme */
        #project-actions button {
            width: 200px;
            height: 45px;
            margin: 0 5px;
            padding: 12px 20px;
            box-sizing: border-box;
            vertical-align: top;
            line-height: 1.2;
        }

        /* ===== ESTILOS RESPONSIVE ===== */
        @media (max-width: 1200px) {
            .container { max-width: 95%; margin: 0 2.5%; }
            .header { padding: 20px; }
            .header h1 { font-size: 2rem; }
            .timeline-container { padding: 20px; }
            .s-curve-section, .calendar-section { padding: 20px; }
        }

        @media (max-width: 768px) {
            body { padding: 5px; }
            .container { max-width: 100%; margin: 0; border-radius: 10px; }
            .header { padding: 15px; text-align: center; }
            .header h1 { font-size: 1.5rem; }
            .header p { font-size: 1rem; }
            .company-logo img { width: 150px; }
            .progress-summary { padding: 15px; }
            .progress-bar-container { height: 15px; }
            .progress-stats { flex-direction: column; gap: 10px; align-items: center; }
            .stat-item { text-align: center; }
            .timeline-container { padding: 15px; }
            .phases-container { margin-bottom: 20px; }
            .phase-header { padding: 10px 15px; font-size: 1.1rem; }
            .phase-number { width: 35px; height: 35px; font-size: 1rem; }
            .tasks-timeline { padding-left: 15px; }
            .task { padding: 10px 15px; }
            .task-content { flex-direction: column; gap: 10px; }
            .task-left { min-width: auto; }
            .task-right { flex-direction: column; align-items: flex-start; gap: 8px; }
            .task-details { flex-direction: column; gap: 5px; align-items: flex-start; }
            .task-times { flex-direction: column; gap: 5px; }
            .project-dates-interactive { padding: 15px; }
            .config-section { grid-template-columns: 1fr; }
            .config-item { flex-direction: column; align-items: flex-start; gap: 8px; min-height: auto; }
            .config-item label { min-width: auto; font-weight: 600; }
            .config-buttons { flex-direction: column; gap: 10px; }
            .config-buttons button { width: 100%; }
            .holidays-list { padding: 10px; }
            .holiday-item { flex-direction: column; align-items: stretch; gap: 5px; }
            .holiday-item input { min-width: auto; width: 100%; }
            .holiday-item button { align-self: flex-end; width: auto; }
            .s-curve-metrics { flex-direction: column; gap: 15px; align-items: center; }
            .metric-card { min-width: 250px; width: 100%; max-width: 300px; }
            .calendar-section { padding: 15px; }
            .calendar-header { margin-bottom: 20px; }
            .calendar-header h2 { font-size: 1.5rem; }
            .semester-calendar { grid-template-columns: 1fr; gap: 15px; }
            .month-container { padding: 10px; }
            .calendar-grid { grid-template-columns: repeat(7, 1fr); }
            .calendar-day { min-height: 35px; font-size: 0.7rem; padding: 1px; }
            .calendar-day-header { font-size: 0.6rem; padding: 3px 1px; min-height: 16px; }
            .task-indicator, .milestone-indicator { width: 14px; height: 14px; font-size: 0.5rem; margin: 0.5px; }
            .calendar-legend { grid-template-columns: 1fr; padding: 15px; }
            .legend-calendar-item { min-width: auto; justify-content: center; }
            #project-actions { text-align: center; margin: 15px 0; }
            #project-actions button { width: 100%; max-width: 300px; margin: 5px 0; font-size: 0.9rem; }
            #download-pdf { margin: 10px 5px; padding: 8px 15px; font-size: 0.9rem; }
            #back-to-projects-btn { margin: 10px 5px; padding: 8px 15px; font-size: 0.9rem; }
            #logout-btn { margin: 10px 5px; padding: 8px 15px; font-size: 0.9rem; }
            #floatingNavBtn { bottom: 20px; right: 20px; padding: 12px 16px; font-size: 1.5rem; }
            .modal-content { max-width: 90%; padding: 20px; }
            .modal-header h3 { font-size: 1.2rem; }
            .modal-task-item { padding: 12px; }
            .modal-task-name { font-size: 0.9rem; }
            .modal-task-details { font-size: 0.8rem; }
        }

        @media (max-width: 480px) {
            .header h1 { font-size: 1.3rem; }
            .header p { font-size: 0.9rem; }
            .company-logo img { width: 120px; }
            .progress-text { font-size: 0.9rem; }
            .stat-number { font-size: 1.2rem; }
            .phase-header { font-size: 1rem; padding: 8px 12px; }
            .phase-number { width: 30px; height: 30px; font-size: 0.9rem; }
            .task { padding: 8px 12px; }
            .task-name { font-size: 0.9rem; }
            .task-hours { font-size: 0.8rem; padding: 2px 6px; }
            .task-dates { font-size: 0.7rem; }
            .metric-card { padding: 15px; }
            .metric-value { font-size: 1.5rem; }
            .metric-label { font-size: 0.8rem; }
            .calendar-day { min-height: 30px; }
            .calendar-day .task-indicator, .calendar-day .milestone-indicator { margin: 0.5px; }
            .calendar-legend { padding: 10px; }
            .modal-content { padding: 15px; }
            .modal-header { padding-bottom: 10px; }
            .modal-tasks-list { max-height: 60vh; }
        }
    </style>
</head>
<body>
    <div class="container" id="project-container">
        <div class="header">
            <div class="company-logo">
                <img src="logo_2025web.png" alt="Logo G&N CE" width="200">
            </div>
            <h1 id="project-name">Cargando proyecto...</h1>
            <p>Cronograma de Proyecto - L√≠nea de Tiempo Interactiva</p>
            <div class="progress-summary">
                <div class="progress-text">Progreso General del Proyecto</div>
                <div class="progress-bar-container">
                    <div class="progress-bar-fill" id="overall-progress"><span id="progress-text">0%</span></div>
                </div>
                <div class="progress-stats">
                    <div class="stat-item">
                        <span class="stat-number" id="total-tasks">0</span>
                        <span>Total de Tareas</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" id="total-hours">0</span>
                        <span>Total de Horas</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" id="completed-tasks">0</span>
                        <span>Tareas Completadas</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" id="completed-hours">0</span>
                        <span>Horas Completadas</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="timeline-container">
            <div class="project-dates-interactive" id="informacionProyecto">
                <h3>Datos generales del Proyecto</h3>
                <div class="project-config">
                    <div class="config-item">
                        <label for="start-date-input">Fecha de Inicio:</label>
                        <input type="date" id="start-date-input">
                    </div>
                    <div class="config-item">
                        <label for="include-saturdays">Excluir S√°bados:</label>
                        <input type="checkbox" id="include-saturdays">
                    </div>
                    <div class="config-item">
                        <label for="include-sundays">Excluir Domingos:</label>
                        <input type="checkbox" id="include-sundays">
                    </div>
                    <div class="config-item">
                        <label for="include-holidays">Excluir Festivos del calendario laboral:</label>
                        <input type="checkbox" id="include-holidays">
                    </div>
                    <div class="config-item">
                        <label for="shift-start-time">Hora Inicio Turno:</label>
                        <input type="time" id="shift-start-time" value="08:00">
                    </div>
                    <div class="config-item">
                        <label for="shift-end-time">Hora Fin Turno:</label>
                        <input type="time" id="shift-end-time" value="17:00">
                    </div>
                    <div class="config-item">
                        <label for="shift-break-hours">Horas Descanso Turno:</label>
                        <input type="number" id="shift-break-hours" min="0" max="8" step="0.5" value="1">
                    </div>
                    <div class="holidays-list" id="holidays-list" style="display: none;">
                        <h4>Festivos Seleccionados:</h4>
                        <div id="holidays-container"></div>
                        <button type="button" id="add-holiday-btn">Agregar Festivo</button>
                    </div>
                    <div class="config-buttons">
                        <button id="recalculate-dates-btn">Aplicar Cambios</button>
                    </div>
                </div>
                <div class="date-info">
                    <p><strong>Inicio:</strong> <span id="project-start-date">--</span></p>
                    <p><strong>Fin Estimado:</strong> <span id="project-end-date">--</span></p>
                    <p><strong>Duraci√≥n:</strong> <span id="project-duration">--</span> d√≠as</p>
                    <p><strong>√öltima Actualizaci√≥n:</strong> <span id="project-last-update">--</span></p>
                </div>
            </div>
            <div id="phases-container" class="phases-container">
                <!-- Las fases y tareas se cargar√°n aqu√≠ -->
            </div>
            
            <!-- Leyenda de tareas -->
            <div class="tasks-legend">
                <h3>Leyenda de Tareas</h3>
                <div class="legend-items">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f8f9fa; border-left: 4px solid #bdc3c7;"></div>
                        <span>Tarea Regular</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color milestone" style="background: linear-gradient(135deg, #fff5f5, #ffeaea); border-left: 4px solid #e74c3c;"></div>
                        <span>Hito üéØ</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color completed" style="background: #d4edda; border-left: 4px solid #28a745;"></div>
                        <span>Tarea Completada ‚úÖ</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-symbol">
                            <span class="task-hours-example">8h</span>
                        </div>
                        <span>Horas de la tarea</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-symbol">
                            <span class="task-dates-example">01/01 - 05/01</span>
                        </div>
                        <span>Fechas de inicio y fin</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-symbol">
                            <span style="font-size: 0.7rem; color: #2c3e50;">08:00 - 17:00</span>
                        </div>
                        <span>Horas espec√≠ficas de tareas</span>
                    </div>
                </div>
            </div>
            
            <div class="calendar-section" id="calendarioProyecto">
                <h2>Calendario del Proyecto</h2>
                <div id="calendar-container"></div>
            </div>

            <!-- Modal de tareas del d√≠a -->
            <div id="day-tasks-modal" class="modal-overlay">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3 id="modal-date-title">Tareas del d√≠a</h3>
                        <button id="close-modal-btn" class="close-modal-btn">&times;</button>
                    </div>
                    <div id="modal-tasks-list" class="modal-tasks-list">
                        <!-- Las tareas se cargar√°n aqu√≠ din√°micamente -->
                    </div>
                </div>
            </div>

            <div class="s-curve-section" id="curvaSProyecto">
                <h2>Curva S - Seguimiento del Proyecto</h2>
                <div id="s-curve-chart" style="width: 100%; height: 500px;"></div>
                <div class="s-curve-metrics">
                    <div class="metric-card">
                        <div class="metric-value" id="schedule-variance">--</div>
                        <div class="metric-label">Variaci√≥n de Cronograma</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="performance-index">--</div>
                        <div class="metric-label">√çndice de Rendimiento</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="project-status">--</div>
                        <div class="metric-label">Estado del Proyecto</div>
                    </div>
                </div>
            </div>

            <div style="text-align: center; margin: 20px 0;" id="project-actions">
                <button id="download-pdf">Descargar Resumen en PDF</button>
                <button id="back-to-projects-btn">Volver a Proyectos</button>
                <button id="logout-btn">Cerrar Sesi√≥n</button>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

    <!-- Bot√≥n flotante de navegaci√≥n -->
    <div id="floatingNavBtn">
        <span>‚ò∞</span>
        <div id="floatingNavMenu">
            <a href="#informacionProyecto">Informaci√≥n</a>
            <a href="#phases-container">Fases</a>
            <a href="#calendarioProyecto">Calendario</a>
            <a href="#curvaSProyecto">Curva S</a>
            <a href="#project-actions">Finalizar</a>
        </div>
    </div>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyBX1H8MaD6eoIo0jbpVRKO-fGtND3PthlI",
            authDomain: "pdt-futura.firebaseapp.com",
            projectId: "pdt-futura",
            storageBucket: "pdt-futura.appspot.com",
            messagingSenderId: "807986666483",
            appId: "1:807986666483:web:4213a33d83132845c87931"
        };

        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.firestore();

        document.addEventListener('DOMContentLoaded', async () => {
            const params = new URLSearchParams(window.location.search);
            const projectId = params.get('id');
            const autoDownload = params.get('download');
            const container = document.getElementById('project-container');

            if (!projectId) {
                container.innerHTML = '<h1>Error: No se especific√≥ un ID de proyecto.</h1>';
                return;
            }

            try {
                const docRef = db.collection('projects').doc(projectId);
                const docSnap = await docRef.get();

                if (!docSnap.exists) {
                    container.innerHTML = `<h1>Error: No se encontr√≥ el proyecto con ID ${projectId}.</h1>`;
                    return;
                }

                const projectData = docSnap.data();
                renderProject(projectData, autoDownload);

            } catch (error) {
                console.error("Error al cargar el proyecto:", error);
                container.innerHTML = '<h1>Error al cargar el proyecto. Revise la consola.</h1>';
            }
        });

        // Funci√≥n helper para formatear fechas de manera consistente
        function formatDateForDisplay(date) {
            if (!date || isNaN(date.getTime())) return '--';
            return date.toLocaleDateString('es-ES');
        }

        function closeDayTasksModal() {
            const modal = document.getElementById('day-tasks-modal');
            modal.classList.remove('show');
            document.body.style.overflow = ''; // Restaurar scroll del body
        }

        // Funciones para interacciones del calendario
        function setupCalendarInteractions(data) {
            console.log('Configurando interacciones del calendario...');
            
            // Configurar tooltips para indicadores de tareas
            document.querySelectorAll('.task-indicator[data-task-tooltip], .milestone-indicator[data-task-tooltip]').forEach(indicator => {
                // Configurar navegaci√≥n al hacer click en tarea (con soporte touch)
                const handleNavigation = (e) => {
                    e.stopPropagation(); // Evitar que se active el click del d√≠a
                    const phaseIndex = parseInt(e.target.getAttribute('data-phase-index'));
                    const taskIndex = parseInt(e.target.getAttribute('data-task-index'));
                    if (!isNaN(phaseIndex) && !isNaN(taskIndex)) {
                        navigateToTask(phaseIndex, taskIndex);
                    }
                };
                
                // Event listeners para mouse (desktop)
                indicator.addEventListener('mouseenter', (e) => {
                    // console.log('MOUSE ENTER en indicador:', e.target);
                    const tooltipText = e.target.getAttribute('data-task-tooltip');
                    // console.log('Texto del tooltip:', tooltipText);
                    if (tooltipText && tooltipText.trim()) {
                        // console.log('Llamando a showTooltip con:', tooltipText);
                        showTooltip(e.target, tooltipText);
                    } else {
                        // console.log('No hay texto para tooltip');
                    }
                });
                
                indicator.addEventListener('mouseleave', () => {
                    // console.log('MOUSE LEAVE en indicador');
                    hideTooltip();
                });
                
                // Event listeners para navegaci√≥n (click y touch)
                indicator.addEventListener('click', handleNavigation);
                indicator.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevenir zoom
                    handleNavigation(e);
                }, { passive: false });
            });
            
            // Configurar tooltips para d√≠as con tareas (como respaldo)
            document.querySelectorAll('.calendar-day.has-task, .calendar-day.has-milestone').forEach(day => {
                day.addEventListener('mouseenter', (e) => {
                    // Solo mostrar tooltip si no hay indicadores espec√≠ficos
                    const indicators = day.querySelectorAll('.task-indicator, .milestone-indicator');
                    if (indicators.length === 0) {
                        const dateStr = day.getAttribute('data-date');
                        if (dateStr) {
                            const [year, month, dayNum] = dateStr.split('-').map(Number);
                            const date = new Date(year, month - 1, dayNum);
                            const dayTasks = getTasksForDate(date, data);
                            if (dayTasks.length > 0) {
                                const tooltipText = dayTasks.map(t => `${t.name} (${t.durationHours}h)`).join('\n');
                                showTooltip(day, tooltipText);
                            }
                        }
                    }
                });
                
                day.addEventListener('mouseleave', () => {
                    hideTooltip();
                });
            });
            
            // Configurar click en d√≠as del calendario (con soporte touch para m√≥viles)
            document.querySelectorAll('.calendar-day').forEach(day => {
                // Event listener para click (desktop)
                day.addEventListener('click', (e) => {
                    const dateStr = e.currentTarget.getAttribute('data-date');
                    if (dateStr) {
                        // Crear fecha desde YYYY-MM-DD formato sin problemas de zona horaria
                        const [year, month, day] = dateStr.split('-').map(Number);
                        const date = new Date(year, month - 1, day); // month es 0-indexed
                        showDayTasksModal(date, data);
                    }
                });
                
                // Event listener para touch (m√≥viles) - previene el comportamiento por defecto
                day.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevenir zoom y scroll
                    const dateStr = e.currentTarget.getAttribute('data-date');
                    if (dateStr) {
                        // Crear fecha desde YYYY-MM-DD formato sin problemas de zona horaria
                        const [year, month, day] = dateStr.split('-').map(Number);
                        const date = new Date(year, month - 1, day); // month es 0-indexed
                        showDayTasksModal(date, data);
                    }
                }, { passive: false });
            });
            
            // Configurar cierre del modal
            document.getElementById('close-modal-btn').addEventListener('click', closeDayTasksModal);
            document.getElementById('day-tasks-modal').addEventListener('click', (e) => {
                if (e.target.id === 'day-tasks-modal') {
                    closeDayTasksModal();
                }
            });
        }

        function setupLogoutFunctionality() {
            const logoutBtn = document.getElementById('logout-btn');
            if (logoutBtn) {
                logoutBtn.addEventListener('click', () => {
                    // Confirmar antes de cerrar sesi√≥n
                    if (confirm('¬øEst√°s seguro de que quieres cerrar la sesi√≥n y volver a la p√°gina principal?')) {
                        // Redirigir a la p√°gina principal
                        window.location.href = 'index.html';
                    }
                });
            }
        }

        function setupBackToProjectsFunctionality() {
            const backToProjectsBtn = document.getElementById('back-to-projects-btn');
            if (backToProjectsBtn) {
                backToProjectsBtn.addEventListener('click', () => {
                    // Confirmar antes de volver a la lista de proyectos
                    if (confirm('¬øEst√°s seguro de que quieres volver a la lista de proyectos? Los cambios no guardados se perder√°n.')) {
                        // Redirigir a la p√°gina de proyectos
                        window.location.href = 'proyectos.html';
                    }
                });
            }
        }

        function setupHolidaysFunctionality(data) {
            // Event listener para el checkbox de festivos
            document.getElementById('include-holidays').addEventListener('change', toggleHolidaysList);
            
            // Event listener para agregar festivo
            const addHolidayBtn = document.getElementById('add-holiday-btn');
            if (addHolidayBtn) {
                // Limpiar event listeners anteriores para evitar duplicados
                const newBtn = addHolidayBtn.cloneNode(true);
                addHolidayBtn.parentNode.replaceChild(newBtn, addHolidayBtn);
                
                newBtn.addEventListener('click', () => {
                    const container = document.getElementById('holidays-container');
                    const holidayItem = document.createElement('div');
                    holidayItem.className = 'holiday-item';
                    holidayItem.innerHTML = `
                        <input type="date">
                        <input type="text" placeholder="Nombre del festivo">
                        <button type="button" onclick="removeHolidayItem(this)">Eliminar</button>
                    `;
                    container.appendChild(holidayItem);
                });
            }
        }

        async function calculateDatesWithConfig(data, newStartDate, config) {
            console.log('Calculando fechas con configuraci√≥n:', config);

            // Crear una copia profunda del proyecto
            const updatedData = JSON.parse(JSON.stringify(data));

            // Funci√≥n helper para verificar si una fecha es d√≠a laborable
            function isWorkingDay(date, config) {
                const dayOfWeek = date.getDay();
                const isWeekend = (dayOfWeek === 0 && config.includeSundays) || (dayOfWeek === 6 && config.includeSaturdays);
                const isHoliday = config.includeHolidays ? isHolidayDate(date, config.holidays) : false;
                return !isWeekend && !isHoliday;
            }

            // Funci√≥n helper para encontrar el siguiente d√≠a laborable desde una fecha
            function findNextWorkingDay(startDate, config) {
                const date = new Date(startDate);
                while (!isWorkingDay(date, config)) {
                    date.setDate(date.getDate() + 1);
                }
                return date;
            }

            // VALIDAR Y AJUSTAR FECHA DE INICIO DEL PROYECTO
            let projectStartDate = new Date(newStartDate);
            if (!isWorkingDay(projectStartDate, config)) {
                console.log('Fecha de inicio no es d√≠a laborable, ajustando al siguiente d√≠a laborable');
                projectStartDate = findNextWorkingDay(projectStartDate, config);
            }

            // Actualizar configuraci√≥n y fecha de inicio
            updatedData.startDate = firebase.firestore.Timestamp.fromDate(projectStartDate);
            updatedData.includeSaturdays = config.includeSaturdays;
            updatedData.includeSundays = config.includeSundays;
            updatedData.includeHolidays = config.includeHolidays;
            updatedData.holidays = config.holidays;
            
            // Guardar configuraci√≥n del turno
            updatedData.shiftStartTime = config.shiftStartTime;
            updatedData.shiftEndTime = config.shiftEndTime;
            updatedData.shiftBreakHours = config.shiftBreakHours;
            updatedData.effectiveShiftHours = config.effectiveShiftHours;
            
            updatedData.lastUpdated = firebase.firestore.Timestamp.now();

            // CALCULAR FECHAS DE TAREAS CON L√ìGICA CORRECTA DE HORAS POR D√çA
            // Parsear horas del turno desde configuraci√≥n
            const shiftStartTime = config.shiftStartTime ? parseInt(config.shiftStartTime.split(':')[0]) + parseInt(config.shiftStartTime.split(':')[1]) / 60 : 8; // Hora inicio turno en horas decimales
            const shiftEndTime = config.shiftEndTime ? parseInt(config.shiftEndTime.split(':')[0]) + parseInt(config.shiftEndTime.split(':')[1]) / 60 : 24; // Hora fin turno en horas decimales
            const shiftBreakHours = config.shiftBreakHours || 1; // Horas de descanso
            const shiftBreakStart = 12; // Inicio del descanso a las 12:00 (configurable si es necesario)
            const shiftBreakEnd = shiftBreakStart + shiftBreakHours; // Fin del descanso

            let currentDate = new Date(projectStartDate); // Comenzar desde la fecha de inicio validada
            let hoursRemainingToday = shiftEndTime - shiftStartTime - shiftBreakHours; // Horas efectivas disponibles en el d√≠a actual (considerando descanso)

            let currentTimeInDay = shiftStartTime; // Hora actual en el d√≠a (en horas decimales)
            let taskCounter = 1;

            let adjustedTaskEndTime; // Variable para ajustar hora de fin cuando termina en descanso

            console.log(`Iniciando c√°lculo desde ${currentDate.toLocaleDateString('es-ES')} con ${hoursRemainingToday}h disponibles por d√≠a`);
            console.log(`Turno: ${shiftStartTime.toFixed(2)}h - ${shiftEndTime.toFixed(2)}h, Descanso: ${shiftBreakHours}h (${shiftBreakStart}-${shiftBreakEnd}h)`);

            updatedData.phases.forEach((phase, phaseIndex) => {
                phase.tasks.forEach((task, taskIndex) => {
                    const taskHours = task.durationHours;
                    let hoursRemainingForTask = taskHours; // Horas que a√∫n necesita esta tarea

                    console.log(`\n=== TAREA ${taskCounter}: ${task.name} (${taskHours}h) ===`);
                    console.log(`Fecha actual: ${currentDate.toLocaleDateString('es-ES')}, Horas disponibles hoy: ${hoursRemainingToday}h`);

                    // Fecha de inicio de la tarea (siempre es la fecha actual cuando comienza)
                    const taskStartDate = new Date(currentDate);
                    const taskStartTime = currentTimeInDay; // Hora de inicio en horas decimales

                    // SIMULAR PRIMERO LA ASIGNACI√ìN COMPLETA PARA CALCULAR FECHAS DE FIN
                    let tempDate = new Date(currentDate);
                    let tempTimeInDay = currentTimeInDay;
                    let tempHoursRemainingToday = hoursRemainingToday;
                    let tempHoursRemainingForTask = taskHours;

                    console.log(`  Simulando asignaci√≥n para tarea de ${taskHours}h comenzando ${tempDate.toLocaleDateString('es-ES')} ${tempTimeInDay.toFixed(2)}h`);

                    // Simular la asignaci√≥n completa para calcular fecha y hora de fin
                    while (tempHoursRemainingForTask > 0) {
                        // Si no quedan horas en el d√≠a actual, pasar al siguiente d√≠a laborable
                        if (tempHoursRemainingToday <= 0 || tempTimeInDay >= shiftEndTime) {
                            tempDate.setDate(tempDate.getDate() + 1);
                            while (!isWorkingDay(tempDate, config)) {
                                tempDate.setDate(tempDate.getDate() + 1);
                            }
                            tempHoursRemainingToday = shiftEndTime - shiftStartTime - shiftBreakHours;
                            tempTimeInDay = shiftStartTime;
                        }

                        // Aplicar descanso si es necesario (durante el horario de descanso)
                        if (tempTimeInDay >= shiftBreakStart && tempTimeInDay < shiftBreakEnd) {
                            tempTimeInDay = shiftBreakEnd;
                            tempHoursRemainingToday = Math.max(0, shiftEndTime - shiftBreakEnd);
                        }

                        // Calcular horas disponibles ahora (respetando l√≠mites del turno y descanso)
                        let hoursAvailableNow = 0;

                        if (tempTimeInDay >= shiftBreakStart && tempTimeInDay < shiftBreakEnd) {
                            // Estamos en descanso, no hay horas disponibles
                            hoursAvailableNow = 0;
                        } else if (tempTimeInDay < shiftBreakStart) {
                            // Antes del descanso: trabajar hasta el descanso
                            hoursAvailableNow = Math.min(tempHoursRemainingToday, shiftBreakStart - tempTimeInDay);
                        } else {
                            // Despu√©s del descanso: trabajar hasta el fin del turno
                            hoursAvailableNow = Math.min(tempHoursRemainingToday, shiftEndTime - tempTimeInDay);
                        }

                        const hoursToAssignToday = Math.min(tempHoursRemainingForTask, hoursAvailableNow);
                        tempHoursRemainingForTask -= hoursToAssignToday;
                        tempHoursRemainingToday -= hoursToAssignToday;
                        tempTimeInDay += hoursToAssignToday;

                        // Si llega exactamente al inicio del descanso Y hay horas restantes, saltar al descanso
                        if (tempTimeInDay === shiftBreakStart && tempHoursRemainingForTask > 0) {
                            tempTimeInDay = shiftBreakEnd;
                            tempHoursRemainingToday = Math.max(0, shiftEndTime - shiftBreakEnd);
                        }
                    }

                    // Ahora tenemos la fecha y hora de fin calculadas
                    const taskEndDate = new Date(tempDate);
                    const taskEndTime = tempTimeInDay;

                    console.log(`  Tarea terminar√°: ${taskEndDate.toLocaleDateString('es-ES')} ${taskEndTime.toFixed(2)}h`);

                    // AHORA HACER LA ASIGNACI√ìN REAL (sin modificar las fechas ya calculadas)
                    hoursRemainingForTask = taskHours;
                    while (hoursRemainingForTask > 0) {
                        console.log(`  Asignando ${hoursRemainingForTask}h restantes. Disponible hoy: ${hoursRemainingToday}h`);

                        // Si no quedan horas en el d√≠a actual, pasar al siguiente d√≠a laborable
                        if (hoursRemainingToday <= 0 || currentTimeInDay >= shiftEndTime) {
                            console.log(`  No quedan horas hoy, pasando al siguiente d√≠a laborable`);
                            currentDate.setDate(currentDate.getDate() + 1);
                            while (!isWorkingDay(currentDate, config)) {
                                currentDate.setDate(currentDate.getDate() + 1);
                            }
                            hoursRemainingToday = shiftEndTime - shiftStartTime - shiftBreakHours;
                            currentTimeInDay = shiftStartTime;
                            console.log(`  Nuevo d√≠a: ${currentDate.toLocaleDateString('es-ES')} con ${hoursRemainingToday}h disponibles`);
                        }

                        // Aplicar descanso si es necesario
                        if (currentTimeInDay >= shiftBreakStart && currentTimeInDay < shiftBreakEnd) {
                            currentTimeInDay = shiftBreakEnd;
                            hoursRemainingToday = Math.max(0, shiftEndTime - shiftBreakEnd);
                        }

                        // Calcular horas disponibles ahora (respetando l√≠mites del turno y descanso)
                        let hoursAvailableNow = 0;

                        if (currentTimeInDay >= shiftBreakStart && currentTimeInDay < shiftBreakEnd) {
                            // Estamos en descanso, no hay horas disponibles
                            hoursAvailableNow = 0;
                        } else if (currentTimeInDay < shiftBreakStart) {
                            // Antes del descanso: trabajar hasta el descanso
                            hoursAvailableNow = Math.min(hoursRemainingToday, shiftBreakStart - currentTimeInDay);
                        } else {
                            // Despu√©s del descanso: trabajar hasta el fin del turno
                            hoursAvailableNow = Math.min(hoursRemainingToday, shiftEndTime - currentTimeInDay);
                        }

                        const hoursToAssignToday = Math.min(hoursRemainingForTask, hoursAvailableNow);
                        console.log(`  Asignando ${hoursToAssignToday}h de esta tarea al d√≠a ${currentDate.toLocaleDateString('es-ES')}`);

                        hoursRemainingForTask -= hoursToAssignToday;
                        hoursRemainingToday -= hoursToAssignToday;
                        currentTimeInDay += hoursToAssignToday;

                        // Si llega exactamente al inicio del descanso Y hay horas restantes, saltar al descanso
                        if (currentTimeInDay === shiftBreakStart && hoursRemainingForTask > 0) {
                            currentTimeInDay = shiftBreakEnd;
                            hoursRemainingToday = Math.max(0, shiftEndTime - shiftBreakEnd);
                        }

                        console.log(`  Tarea ahora necesita ${hoursRemainingForTask}h m√°s. Quedan ${hoursRemainingToday}h disponibles hoy. Hora actual: ${currentTimeInDay.toFixed(2)}h`);
                    }

                    console.log(`  ‚úì TAREA COMPLETADA: ${taskStartDate.toLocaleDateString('es-ES')} ${taskStartTime.toFixed(2)}h ‚Üí ${taskEndDate.toLocaleDateString('es-ES')} ${taskEndTime.toFixed(2)}h`);

                    // Convertir horas decimales a formato HH:MM
                    function decimalHoursToTime(decimalHours) {
                        const hours = Math.floor(decimalHours);
                        const minutes = Math.round((decimalHours - hours) * 60);
                        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                    }

                    // Actualizar las fechas y horas de la tarea
                    updatedData.phases[phaseIndex].tasks[taskIndex].startDate = firebase.firestore.Timestamp.fromDate(taskStartDate);
                    updatedData.phases[phaseIndex].tasks[taskIndex].endDate = firebase.firestore.Timestamp.fromDate(taskEndDate);
                    updatedData.phases[phaseIndex].tasks[taskIndex].startTime = decimalHoursToTime(taskStartTime);
                    updatedData.phases[phaseIndex].tasks[taskIndex].endTime = decimalHoursToTime(taskEndTime);

                    // La siguiente tarea puede comenzar inmediatamente si quedan horas disponibles,
                    // o al d√≠a siguiente si no quedan horas
                    if (hoursRemainingToday <= 0 || currentTimeInDay >= shiftEndTime) {
                        // No quedan horas hoy, la siguiente tarea comenzar√° ma√±ana
                        currentDate.setDate(currentDate.getDate() + 1);
                        while (!isWorkingDay(currentDate, config)) {
                            currentDate.setDate(currentDate.getDate() + 1);
                        }
                        hoursRemainingToday = shiftEndTime - shiftStartTime - shiftBreakHours; // Resetear horas efectivas disponibles
                        currentTimeInDay = shiftStartTime; // Resetear hora del d√≠a
                        console.log(`  ‚Üí Siguiente tarea comenzar√° el ${currentDate.toLocaleDateString('es-ES')} (d√≠a siguiente laborable)`);
                    } else {
                        // Preparar para la siguiente tarea aplicando descanso si es necesario
                        if (currentTimeInDay >= shiftBreakStart && currentTimeInDay < shiftBreakEnd) {
                            currentTimeInDay = shiftBreakEnd;
                            hoursRemainingToday = Math.max(0, shiftEndTime - shiftBreakEnd);
                        }
                        console.log(`  ‚Üí Siguiente tarea puede comenzar hoy mismo (${hoursRemainingToday}h restantes a las ${currentTimeInDay.toFixed(2)}h)`);
                    }

                    taskCounter++;
                });
            });

            console.log('Fechas recalculadas:', updatedData);
            return updatedData;
        }

        // Hacer la funci√≥n global para que sea accesible desde el bot√≥n
        window.recalculateDates = recalculateDates;

        // Funci√≥n wrapper para recalcular fechas usando la configuraci√≥n actual
        async function recalculateDates(data) {
            // Obtener la fecha de inicio actual del input
            const startDateInput = document.getElementById('start-date-input');
            const newStartDate = createDateFromInput(startDateInput.value);

            if (!newStartDate) {
                throw new Error('Por favor, selecciona una fecha de inicio v√°lida.');
            }

            // Preparar configuraci√≥n actual
            const config = {
                includeSaturdays: document.getElementById('include-saturdays').checked,
                includeSundays: document.getElementById('include-sundays').checked,
                includeHolidays: document.getElementById('include-holidays').checked,
                holidays: getHolidaysFromUI(),
                shiftStartTime: document.getElementById('shift-start-time').value,
                shiftEndTime: document.getElementById('shift-end-time').value,
                shiftBreakHours: parseFloat(document.getElementById('shift-break-hours').value) || 1,
                effectiveShiftHours: 0 // Se calcular√° dentro de la funci√≥n
            };

            // Llamar a la funci√≥n principal con los par√°metros preparados
            return await calculateDatesWithConfig(data, newStartDate, config);
        }

        // Funci√≥n helper para guardar el proyecto de manera consistente
        async function saveProject(data) {
            try {
                const params = new URLSearchParams(window.location.search);
                const projectId = params.get('id');
                
                // Asegurar que todos los campos necesarios est√©n presentes
                const projectToSave = {
                    ...data,
                    lastUpdated: firebase.firestore.Timestamp.now(),
                    // Asegurar valores por defecto para configuraci√≥n
                    includeSaturdays: data.includeSaturdays !== undefined ? data.includeSaturdays : true,
                    includeSundays: data.includeSundays !== undefined ? data.includeSundays : true,
                    includeHolidays: data.includeHolidays !== undefined ? data.includeHolidays : true,
                    holidays: data.holidays || [],
                    shiftStartTime: data.shiftStartTime || '08:00',
                    shiftEndTime: data.shiftEndTime || '17:00',
                    shiftBreakHours: data.shiftBreakHours !== undefined ? data.shiftBreakHours : 1
                };
                
                await db.collection('projects').doc(projectId).update(projectToSave);
                
                // Actualizar la fecha de √∫ltima modificaci√≥n en la UI
                document.getElementById('project-last-update').textContent = new Date().toLocaleString();
                
                console.log('Proyecto guardado exitosamente');
                return true;
            } catch (error) {
                console.error('Error al guardar el proyecto:', error);
                throw error;
            }
        }

        // Funci√≥n helper para crear fecha desde input date (evita problemas de zona horaria)
        function createDateFromInput(inputValue) {
            if (!inputValue) return null;
            // Crear fecha en zona horaria local para evitar problemas
            const date = new Date(inputValue + 'T00:00:00');
            return date;
        }

        // Funci√≥n para obtener d√≠as festivos desde la interfaz de usuario
        function getHolidaysFromUI() {
            const holidayItems = document.querySelectorAll('.holiday-item');
            const holidays = [];
            
            holidayItems.forEach((item, index) => {
                const dateInput = item.querySelector('input[type="date"]');
                const nameInput = item.querySelector('input[type="text"]');
                
                if (dateInput.value && nameInput.value) {
                    holidays.push({
                        date: firebase.firestore.Timestamp.fromDate(new Date(dateInput.value)),
                        name: nameInput.value
                    });
                }
            });
            
            return holidays;
        }

        // Funci√≥n para mostrar tooltip
        function showTooltip(element, text) {
            // Remover tooltip existente
            hideTooltip();
            
            // Crear nuevo tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'calendar-tooltip';
            tooltip.textContent = text;
            
            document.body.appendChild(tooltip);
            
            // Calcular dimensiones despu√©s de agregar al DOM
            const tooltipWidth = tooltip.offsetWidth;
            const tooltipHeight = tooltip.offsetHeight;
            
            // Posicionar tooltip
            const rect = element.getBoundingClientRect();
            
            let top = rect.top - tooltipHeight - 5;
            let left = rect.left + (rect.width / 2) - (tooltipWidth / 2);
            
            // Si no hay espacio arriba, posicionar abajo
            if (top < 0) {
                top = rect.bottom + 5;
            }
            
            // Ajustar si se sale por los lados
            if (left < 0) {
                left = 5;
            } else if (left + tooltipWidth > window.innerWidth) {
                left = window.innerWidth - tooltipWidth - 5;
            }
            
            tooltip.style.top = top + 'px';
            tooltip.style.left = left + 'px';
        }

        // Funci√≥n para ocultar tooltip
        function hideTooltip() {
            const existingTooltip = document.querySelector('.calendar-tooltip');
            if (existingTooltip) {
                existingTooltip.remove();
            }
        }

        // Funci√≥n para navegar a una tarea espec√≠fica
        function navigateToTask(phaseIndex, taskIndex) {
            // Encontrar el elemento de la tarea en las fases
            const phaseElements = document.querySelectorAll('.phase');
            const phaseElement = phaseElements[phaseIndex];
            if (!phaseElement) return;
            
            const taskElements = phaseElement.querySelectorAll('.task');
            const taskElement = taskElements[taskIndex];
            if (!taskElement) return;
            
            // Expandir la fase si est√° colapsada
            if (phaseElement.classList.contains('collapsed')) {
                phaseElement.classList.remove('collapsed');
                const header = phaseElement.querySelector('.phase-header');
                if (header) {
                    header.classList.remove('collapsed');
                }
            }

            // Hacer scroll hacia la tarea con mejor posicionamiento
            taskElement.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'center',
                inline: 'nearest'
            });
            
            // Aplicar clase de resaltado con animaci√≥n
            taskElement.classList.add('task-highlight');
            
            // Remover el resaltado despu√©s de 3 segundos
            setTimeout(() => {
                taskElement.classList.remove('task-highlight');
            }, 3000);
        }

        // Funci√≥n para obtener tareas de una fecha espec√≠fica
        function getTasksForDate(date, data) {
            const tasks = [];
            let taskCounter = 1;

            data.phases.forEach((phase, phaseIndex) => {
                phase.tasks.forEach((task, taskIndex) => {
                    const taskStart = task.startDate && typeof task.startDate.toDate === 'function' ? task.startDate.toDate() : new Date(task.startDate);
                    const taskEnd = task.endDate && typeof task.endDate.toDate === 'function' ? task.endDate.toDate() : new Date(task.endDate);

                    // Si la tarea comienza en esta fecha
                    if (taskStart.toDateString() === date.toDateString()) {
                        tasks.push({
                            ...task,
                            number: taskCounter,
                            isMilestone: task.isMilestone || task.esHito || false,
                            phaseIndex: phaseIndex,
                            taskIndex: taskIndex,
                            phaseName: phase.name
                        });
                    }
                    taskCounter++;
                });
            });

            return tasks;
        }

        // Funci√≥n para mostrar modal con tareas del d√≠a
        function showDayTasksModal(date, data) {
            const modal = document.getElementById('day-tasks-modal');
            const modalTitle = document.getElementById('modal-date-title');
            const tasksList = document.getElementById('modal-tasks-list');
            
            // Establecer t√≠tulo del modal
            modalTitle.textContent = `Tareas del ${date.toLocaleDateString('es-ES')}`;
            
            // Obtener tareas del d√≠a
            const dayTasks = getTasksForDate(date, data);
            
            // Generar contenido del modal
            if (dayTasks.length === 0) {
                tasksList.innerHTML = '<p class="no-tasks">No hay tareas programadas para este d√≠a.</p>';
            } else {
                tasksList.innerHTML = dayTasks.map(task => {
                    const taskType = task.isMilestone ? 'milestone' : 'regular';
                    const statusIcon = task.completed ? '‚úÖ' : '‚è≥';
                    const statusText = task.completed ? 'Completada' : 'Pendiente';
                    
                    // Formatear fechas de inicio y fin
                    const startDate = task.startDate && typeof task.startDate.toDate === 'function' ? task.startDate.toDate() : new Date(task.startDate);
                    const endDate = task.endDate && typeof task.endDate.toDate === 'function' ? task.endDate.toDate() : new Date(task.endDate);
                    const startTime = task.startTime || '';
                    const endTime = task.endTime || '';
                    
                    const startDateStr = startDate.toLocaleDateString('es-ES');
                    const endDateStr = endDate.toLocaleDateString('es-ES');
                    
                    return `
                        <div class="modal-task-item ${taskType}" data-phase-index="${task.phaseIndex}" data-task-index="${task.taskIndex}">
                            <div class="modal-task-header">
                                <span class="modal-task-number">${task.number}</span>
                                <span class="modal-task-status">${statusIcon} ${statusText}</span>
                            </div>
                            <div class="modal-task-info">
                                <div class="modal-task-name">${task.name}</div>
                                <div class="modal-task-details">
                                    <span class="modal-task-phase">Fase: ${task.phaseName}</span>
                                    <span class="modal-task-hours">${task.durationHours}h</span>
                                </div>
                                <div class="modal-task-times">
                                    <div class="modal-task-time-start">
                                        <span class="modal-task-time-label">Inicio:</span>
                                        <span class="modal-task-time-value">${startDateStr} ${startTime || '--:--'}</span>
                                    </div>
                                    <div class="modal-task-time-end">
                                        <span class="modal-task-time-label">Fin:</span>
                                        <span class="modal-task-time-value">${endDateStr} ${endTime || '--:--'}</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Configurar clicks en tareas del modal (con soporte touch)
                tasksList.querySelectorAll('.modal-task-item').forEach(taskItem => {
                    const handleTaskNavigation = () => {
                        const phaseIndex = parseInt(taskItem.getAttribute('data-phase-index'));
                        const taskIndex = parseInt(taskItem.getAttribute('data-task-index'));
                        navigateToTask(phaseIndex, taskIndex);
                        closeDayTasksModal();
                    };
                    
                    // Event listeners para navegaci√≥n
                    taskItem.addEventListener('click', handleTaskNavigation);
                    taskItem.addEventListener('touchstart', (e) => {
                        e.preventDefault(); // Prevenir zoom
                        handleTaskNavigation();
                    }, { passive: false });
                });
            }
            
            // Mostrar modal
            modal.classList.add('show');
            document.body.style.overflow = 'hidden'; // Prevenir scroll del body
        }

        // Funci√≥n para configurar descarga de PDF
        function setupPdfDownload(data) {
            const downloadBtn = document.getElementById('download-pdf');

            // Limpiar event listeners anteriores para evitar descargas m√∫ltiples
            const newBtn = downloadBtn.cloneNode(true);
            downloadBtn.parentNode.replaceChild(newBtn, downloadBtn);

            // Funci√≥n simplificada para generar PDF directamente con jsPDF
            async function generateSimplePDF(data, button = null) {
                console.log('Iniciando generaci√≥n de PDF con formato mejorado...');
                if (button) {
                    button.disabled = true;
                    button.textContent = 'Generando PDF...';
                }

                try {
                    // Usar la funci√≥n centralizada calculateProjectMetrics para obtener todas las m√©tricas
                    const pdfMetrics = calculateProjectMetrics(data);
                    const {
                        totalTasks,
                        totalHours,
                        completedTasks,
                        completedHours,
                        progressPercentage,
                        scheduleVariance,
                        schedulePerformanceIndex,
                        projectStatus,
                        totalWeeks,
                        currentWeek,
                        plannedProgress
                    } = pdfMetrics;

                    // Calcular fechas del proyecto
                    const projectStartDate = data.startDate && typeof data.startDate.toDate === 'function' ? 
                        data.startDate.toDate() : new Date(data.startDate);
                    const lastTask = data.phases[data.phases.length - 1].tasks.slice(-1)[0];
                    const projectEndDate = lastTask.endDate && typeof lastTask.endDate.toDate === 'function' ? 
                        lastTask.endDate.toDate() : new Date(lastTask.endDate);
                    const durationDays = Math.ceil((projectEndDate - projectStartDate) / (1000 * 60 * 60 * 24));

                    // Crear PDF con formato profesional
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF('p', 'mm', 'a4');
                    const pageWidth = pdf.internal.pageSize.getWidth();
                    const pageHeight = pdf.internal.pageSize.getHeight();
                    const margin = 15;
                    const contentWidth = pageWidth - 2 * margin;
                    let yPosition = margin;

                    // Funci√≥n helper para agregar nueva p√°gina si es necesario
                    async function checkPageBreak(requiredSpace = 20) {
                        if (yPosition + requiredSpace > pageHeight - margin) {
                            pdf.addPage();
                            yPosition = margin;
                            // Agregar watermark a cada nueva p√°gina
                            await addWatermark();
                            return true;
                        }
                        return false;
                    }

                    // Funci√≥n helper para agregar marca de agua
                    async function addWatermark(customPageWidth = null, customPageHeight = null) {
                        try {
                            // Intentar cargar el logo
                            const logoImg = new Image();
                            logoImg.crossOrigin = 'anonymous';
                            logoImg.src = 'logo_2025web.png';
                            
                            await new Promise((resolve) => {
                                logoImg.onload = resolve;
                                logoImg.onerror = resolve;
                            });

                            if (logoImg.complete && logoImg.naturalWidth > 0) {
                                pdf.saveGraphicsState();
                                pdf.setGState(pdf.GState({ opacity: 0.08 }));
                                
                                // Calcular dimensiones manteniendo la relaci√≥n de aspecto
                                const originalWidth = logoImg.naturalWidth;
                                const originalHeight = logoImg.naturalHeight;
                                const aspectRatio = originalWidth / originalHeight;
                                
                                // Usar un ancho base y calcular la altura proporcionalmente
                                const logoWidth = 80;
                                const logoHeight = logoWidth / aspectRatio;
                                
                                // Usar las dimensiones de p√°gina proporcionadas o las actuales de la p√°gina
                                const currentPageWidth = customPageWidth || pdf.internal.pageSize.getWidth();
                                const currentPageHeight = customPageHeight || pdf.internal.pageSize.getHeight();
                                
                                const logoX = (currentPageWidth - logoWidth) / 2;
                                const logoY = (currentPageHeight - logoHeight) / 2;
                                pdf.addImage(logoImg, 'PNG', logoX, logoY, logoWidth, logoHeight);
                                pdf.restoreGraphicsState();
                            }
                        } catch (error) {
                            console.log('No se pudo agregar marca de agua:', error);
                        }
                    }

                    // ===== PORTADA =====
                    await addWatermark();

                    // T√≠tulo principal
                    pdf.setFontSize(16);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(31, 41, 55); // color gris oscuro
                    const titleText = 'RESUMEN EJECUTIVO DEL PROYECTO';
                    const titleWidth = pdf.getTextWidth(titleText);
                    pdf.text(titleText, (pageWidth - titleWidth) / 2, yPosition);
                    yPosition += 15;

                    // Nombre del proyecto
                    pdf.setFontSize(18);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(37, 99, 235); // color azul
                    const projectNameLines = pdf.splitTextToSize(data.projectName.toUpperCase(), contentWidth);
                    projectNameLines.forEach(line => {
                        const lineWidth = pdf.getTextWidth(line);
                        pdf.text(line, (pageWidth - lineWidth) / 2, yPosition);
                        yPosition += 10;
                    });
                    yPosition += 20;

                    // Informaci√≥n del sistema
                    pdf.setFontSize(12);
                    pdf.setFont('helvetica', 'normal');
                    pdf.setTextColor(75, 85, 99);
                    const systemInfo = 'Sistema PDT Futura - Gesti√≥n de Proyectos';
                    const systemWidth = pdf.getTextWidth(systemInfo);
                    pdf.text(systemInfo, (pageWidth - systemWidth) / 2, yPosition);
                    yPosition += 8;

                    const generationDate = new Date().toLocaleString('es-ES', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    const dateText = `Generado el ${generationDate}`;
                    const dateWidth = pdf.getTextWidth(dateText);
                    pdf.text(dateText, (pageWidth - dateWidth) / 2, yPosition);
                    yPosition += 30;

                    // ===== RESUMEN EJECUTIVO =====
                    await checkPageBreak(40);
                    
                    // Secci√≥n de m√©tricas principales
                    pdf.setFontSize(16);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(31, 41, 55);
                    pdf.text('M√âTRICAS PRINCIPALES', margin, yPosition);
                    yPosition += 12;

                    // Tabla de m√©tricas usando autoTable
                    const metricsData = [
                        ['Total de Tareas', totalTasks.toString(), 'tareas'],
                        ['Tareas Completadas', completedTasks.toString(), 'tareas'],
                        ['Progreso de Tareas', `${((completedTasks/totalTasks)*100).toFixed(1)}%`, 'completado'],
                        ['Total de Horas', totalHours.toString(), 'horas'],
                        ['Horas Completadas', completedHours.toString(), 'horas'],
                        ['Progreso de Horas', `${progressPercentage.toFixed(1)}%`, 'completado'],
                        ['Duraci√≥n del Proyecto', durationDays.toString(), 'd√≠as'],
                        ['Estado Actual', projectStatus, '']
                    ];

                    pdf.autoTable({
                        startY: yPosition,
                        head: [['M√©trica', 'Valor', 'Unidad']],
                        body: metricsData,
                        theme: 'grid',
                        headStyles: {
                            fillColor: [37, 99, 235],
                            textColor: [255, 255, 255],
                            fontSize: 11,
                            fontStyle: 'bold'
                        },
                        bodyStyles: {
                            fontSize: 10,
                            textColor: [31, 41, 55],
                            fillColor: null // Fondo completamente transparente
                        },
                        alternateRowStyles: {
                            fillColor: null // Fondo completamente transparente
                        },
                        margin: { left: margin, right: margin },
                        tableWidth: 'auto', // Ajustar al ancho completo de la p√°gina
                        columnStyles: {
                            0: { cellWidth: 'auto' },
                            1: { cellWidth: 'auto', halign: 'left', fontStyle: 'bold' },
                            2: { cellWidth: 'auto', halign: 'left' }
                        }
                    });

                    yPosition = pdf.lastAutoTable.finalY + 20;
                    
                    // ===== INFORMACI√ìN DEL PROYECTO =====
                    await checkPageBreak(40);

                    pdf.setFontSize(16);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(31, 41, 55);
                    pdf.text('INFORMACI√ìN DEL PROYECTO', margin, yPosition);
                    yPosition += 12;

                    const projectData = [
                        ['Fecha de Inicio', formatDateForDisplay(projectStartDate)],
                        ['Fecha de Fin Estimada', formatDateForDisplay(projectEndDate)],
                        ['Duraci√≥n Total', `${durationDays} d√≠as (${totalWeeks} semanas)`],
                        ['√öltima Actualizaci√≥n', data.lastUpdated && typeof data.lastUpdated.toDate === 'function' ? 
                            data.lastUpdated.toDate().toLocaleString('es-ES') : 
                            (data.lastUpdated ? new Date(data.lastUpdated).toLocaleString('es-ES') : 'N/A')]
                    ];

                    pdf.autoTable({
                        startY: yPosition,
                        head: [['Informaci√≥n', 'Detalle']],
                        body: projectData,
                        theme: 'grid',
                        headStyles: {
                            fillColor: [22, 163, 74],
                            textColor: [255, 255, 255],
                            fontSize: 11,
                            fontStyle: 'bold'
                        },
                        bodyStyles: {
                            fontSize: 10,
                            textColor: [31, 41, 55],
                            fillColor: null // Fondo completamente transparente
                        },
                        alternateRowStyles: {
                            fillColor: null // Fondo completamente transparente
                        },
                        margin: { left: margin, right: margin },
                        tableWidth: 'auto', // Ajustar al ancho completo de la p√°gina
                        columnStyles: {
                            0: { cellWidth: 'auto', fontStyle: 'bold' },
                            1: { cellWidth: 'auto' }
                        }
                    });

                    yPosition = pdf.lastAutoTable.finalY + 20;

                    // ===== M√âTRICAS DE RENDIMIENTO =====
                    await checkPageBreak(40);

                    pdf.setFontSize(16);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(31, 41, 55);
                    pdf.text('AN√ÅLISIS DE RENDIMIENTO', margin, yPosition);
                    yPosition += 12;

                    const performanceData = [
                        ['Variaci√≥n del Cronograma', 
                         projectStatus === 'Planificado' ? 'N/A' : `${scheduleVariance.toFixed(1)}%`,
                         'Positivo = Adelantado,\nNegativo = Retrasado'],
                        ['√çndice de Rendimiento (SPI)', 
                         projectStatus === 'Planificado' ? 'N/A' : schedulePerformanceIndex.toFixed(2),
                         '>1.0 = Adelantado,\n<1.0 = Retrasado,\n=1.0 = A tiempo'],
                        ['Estado del Proyecto', 
                         projectStatus,
                         projectStatus === 'Planificado' ? 'Fecha de inicio\nen el futuro' : 'Basado en\nprogreso actual'],
                        ['Semana Actual', 
                         `${currentWeek} de ${totalWeeks}`,
                         `${((currentWeek/totalWeeks)*100).toFixed(1)}%\ndel tiempo transcurrido`]
                    ];

                    pdf.autoTable({
                        startY: yPosition,
                        head: [['Indicador', 'Valor', 'Interpretaci√≥n']],
                        body: performanceData,
                        theme: 'grid',
                        headStyles: {
                            fillColor: [220, 38, 38],
                            textColor: [255, 255, 255],
                            fontSize: 11,
                            fontStyle: 'bold'
                        },
                        bodyStyles: {
                            fontSize: 9,
                            textColor: [31, 41, 55],
                            fillColor: null // Fondo completamente transparente
                        },
                        alternateRowStyles: {
                            fillColor: null // Fondo completamente transparente
                        },
                        margin: { left: margin, right: margin },
                        tableWidth: 'auto', // Ajustar al ancho completo de la p√°gina
                        columnStyles: {
                            0: { cellWidth: 'auto', fontStyle: 'bold', fontSize: 9 },
                            1: { cellWidth: 'auto', halign: 'left', fontStyle: 'bold', fontSize: 9 },
                            2: { cellWidth: 'auto', halign: 'left', fontSize: 7 }
                        }
                    });

                    yPosition = pdf.lastAutoTable.finalY + 20;

                    // ===== RESUMEN POR FASES =====
                    await checkPageBreak(50);

                    pdf.setFontSize(16);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(31, 41, 55);
                    pdf.text('RESUMEN POR FASES', margin, yPosition);
                    yPosition += 12;

                    // Crear datos de fases para tabla
                    const phasesData = data.phases.map((phase, index) => {
                        const phaseCompletedTasks = phase.tasks.filter(task => task.completed).length;
                        const phaseTotalHours = phase.tasks.reduce((sum, task) => sum + task.durationHours, 0);
                        const phaseCompletedHours = phase.tasks
                            .filter(task => task.completed)
                            .reduce((sum, task) => sum + task.durationHours, 0);
                        const phaseProgress = phase.tasks.length > 0 ? 
                            ((phaseCompletedTasks / phase.tasks.length) * 100).toFixed(1) : '0.0';

                        return [
                            `Fase ${index + 1}`,
                            phase.name || `Fase ${index + 1}`,
                            `${phaseCompletedTasks}/${phase.tasks.length}`,
                            `${phaseCompletedHours}/${phaseTotalHours}h`,
                            `${phaseProgress}%`
                        ];
                    });

                    pdf.autoTable({
                        startY: yPosition,
                        head: [['#', 'Nombre de la Fase', 'Tareas', 'Horas', 'Progreso']],
                        body: phasesData,
                        theme: 'grid',
                        headStyles: {
                            fillColor: [147, 51, 234],
                            textColor: [255, 255, 255],
                            fontSize: 11,
                            fontStyle: 'bold'
                        },
                        bodyStyles: {
                            fontSize: 10,
                            textColor: [31, 41, 55],
                            fillColor: null // Fondo completamente transparente
                        },
                        alternateRowStyles: {
                            fillColor: null // Fondo completamente transparente
                        },
                        margin: { left: margin, right: margin },
                        tableWidth: 'auto', // Ajustar al ancho completo de la p√°gina
                        columnStyles: {
                            0: { cellWidth: 'auto', halign: 'left', fontStyle: 'bold' },
                            1: { cellWidth: 'auto' },
                            2: { cellWidth: 'auto', halign: 'left' },
                            3: { cellWidth: 'auto', halign: 'left' },
                            4: { cellWidth: 'auto', halign: 'left', fontStyle: 'bold' }
                        }
                    });

                    yPosition = pdf.lastAutoTable.finalY + 20;

                    // ===== DETALLE DE TAREAS =====
                    // Verificar si hay espacio suficiente para el t√≠tulo y al menos algunas filas
                    const titleHeight = 16 + 12; // Altura del t√≠tulo + espacio
                    const minRowsHeight = 8 * 5; // Altura m√≠nima para 5 filas
                    await checkPageBreak(titleHeight + minRowsHeight);

                    pdf.setFontSize(16);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(31, 41, 55);
                    pdf.text('DETALLE DE TAREAS POR FASE', margin, yPosition);
                    yPosition += 12;

                    // Preparar datos de todas las tareas para la tabla
                    const allTasksData = [];
                    let taskCounter = 1;

                    data.phases.forEach((phase, phaseIndex) => {
                        phase.tasks.forEach((task, taskIndex) => {
                            const isMilestone = task.isMilestone || task.esHito || false;
                            const status = task.completed ? 'Completada' : 'Pendiente';
                            const startDate = task.startDate && typeof task.startDate.toDate === 'function' ? task.startDate.toDate() : new Date(task.startDate);
                            const endDate = task.endDate && typeof task.endDate.toDate === 'function' ? task.endDate.toDate() : new Date(task.endDate);

                            allTasksData.push([
                                taskCounter++,
                                task.name,
                                isMilestone ? 'Hito' : 'Tarea',
                                task.durationHours + 'h',
                                startDate.toLocaleDateString('es-ES'),
                                endDate.toLocaleDateString('es-ES'),
                                status
                            ]);
                        });
                    });

                    // Crear tabla completa sin dividir en chunks - dejar que autoTable maneje los saltos de p√°gina autom√°ticamente
                    pdf.autoTable({
                        startY: yPosition,
                        head: [['#', 'Nombre de la Tarea', 'Tipo', 'Horas', 'Inicio', 'Fin', 'Estado']],
                        body: allTasksData,
                        theme: 'grid',
                        tableWidth: 'auto',
                        headStyles: {
                            fillColor: [59, 130, 246],
                            textColor: [255, 255, 255],
                            fontSize: 10,
                            fontStyle: 'bold'
                        },
                        bodyStyles: {
                            fontSize: 8,
                            textColor: [31, 41, 55],
                            fillColor: null
                        },
                        alternateRowStyles: {
                            fillColor: null
                        },
                        margin: { left: margin, right: margin },
                        columnStyles: {
                            0: { cellWidth: 'auto', halign: 'left', fontSize: 7 },
                            1: { cellWidth: 'auto', fontSize: 7 },
                            2: { cellWidth: 'auto', halign: 'left', fontSize: 7 },
                            3: { cellWidth: 'auto', halign: 'left', fontSize: 7 },
                            4: { cellWidth: 'auto', halign: 'left', fontSize: 6 },
                            5: { cellWidth: 'auto', halign: 'left', fontSize: 6 },
                            6: { cellWidth: 'auto', halign: 'left', fontSize: 7, fontStyle: 'bold' }
                        },
                        didParseCell: function(data) {
                            // Colorear el estado seg√∫n el tipo
                            if (data.column.index === 6) {
                                if (data.cell.raw === 'Completada') {
                                    data.cell.styles.textColor = [22, 163, 74];
                                    data.cell.styles.fontStyle = 'bold';
                                } else {
                                    data.cell.styles.textColor = [239, 68, 68];
                                    data.cell.styles.fontStyle = 'bold';
                                }
                            }
                            // Colorear el tipo de tarea
                            if (data.column.index === 2) {
                                if (data.cell.raw === 'Hito') {
                                    data.cell.styles.textColor = [147, 51, 234];
                                    data.cell.styles.fontStyle = 'bold';
                                }
                            }
                        },
                        // Configuraci√≥n para manejar saltos de p√°gina autom√°ticamente
                        pageBreak: 'auto',
                        rowPageBreak: 'avoid',
                        showHead: 'everyPage'
                    });

                    yPosition = pdf.lastAutoTable.finalY + 10;

                    // ===== P√ÅGINA DE CURVA S =====
                    // Agregar nueva p√°gina en formato horizontal para la curva S
                    pdf.addPage('letter', 'landscape');
                    const landscapePageWidth = pdf.internal.pageSize.getWidth();
                    const landscapePageHeight = pdf.internal.pageSize.getHeight();
                    await addWatermark(landscapePageWidth, landscapePageHeight);

                    const landscapeMargin = 20;

                    yPosition = landscapeMargin;

                    // T√≠tulo de la curva S
                    pdf.setFontSize(18);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(31, 41, 55);
                    const curveTitle = 'CURVA S - SEGUIMIENTO DEL PROGRESO DEL PROYECTO';
                    const curveTitleWidth = pdf.getTextWidth(curveTitle);
                    pdf.text(curveTitle, (landscapePageWidth - curveTitleWidth) / 2, yPosition);
                    yPosition += 15;

                    // Generar el gr√°fico de la curva S usando la funci√≥n drawPDFSCurve optimizada
                    try {
                        console.log('Generando gr√°fico de Curva S con funci√≥n optimizada...');

                        // Crear canvas para el gr√°fico con mayor resoluci√≥n
                        const scaleFactor = 4; // Factor de escala aumentado para mayor calidad
                        const chartWidth = landscapePageWidth - 2 * landscapeMargin;
                        const chartHeight = landscapePageHeight - yPosition - landscapeMargin - 30; // M√°s espacio para la gr√°fica
                        const canvasWidth = chartWidth * scaleFactor;
                        const canvasHeight = chartHeight * scaleFactor;

                        const canvas = document.createElement('canvas');
                        canvas.width = canvasWidth;
                        canvas.height = canvasHeight;
                        canvas.style.width = chartWidth + 'px';
                        canvas.style.height = chartHeight + 'px';

                        // Usar la funci√≥n drawPDFSCurve optimizada que incluye todas las etiquetas
                        drawPDFSCurve(canvas, data);

                        // Convertir canvas a imagen
                        const imgData = canvas.toDataURL('image/png', 1.0);
                            pdf.addImage(imgData, 'PNG', landscapeMargin, yPosition, chartWidth, chartHeight - 10);                        console.log('Gr√°fico de Curva S generado exitosamente con funci√≥n optimizada');

                    } catch (chartError) {
                        console.error('Error al generar gr√°fico con funci√≥n optimizada:', chartError);
                        
                        // M√©todo alternativo con Chart.js b√°sico (sin etiquetas)
                        try {
                            console.log('Intentando m√©todo alternativo con Chart.js b√°sico...');
                            
                            const canvas = document.createElement('canvas');
                            canvas.width = (landscapePageWidth - 2 * landscapeMargin) * 2;
                            canvas.height = (landscapePageHeight - yPosition - landscapeMargin) * 2;
                            
                            // Crear Chart.js b√°sico sin plugin de etiquetas
                            const ctx = canvas.getContext('2d');
                            const basicChart = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: projectWeeks,
                                    datasets: [
                                        {
                                            label: 'Progreso Planificado',
                                            data: plannedProgress,
                                            borderColor: '#2563eb',
                                            backgroundColor: 'rgba(37, 99, 235, 0.1)',
                                            borderWidth: 4,
                                            fill: false,
                                            tension: 0.4,
                                            pointRadius: 0
                                        },
                                        {
                                            label: 'Progreso Real',
                                            data: actualProgress,
                                            borderColor: '#16a34a',
                                            backgroundColor: 'rgba(22, 163, 74, 0.1)',
                                            borderWidth: 4,
                                            fill: false,
                                            tension: 0.4,
                                            pointRadius: 0
                                        }
                                    ]
                                },
                                options: {
                                    responsive: false,
                                    maintainAspectRatio: false,
                                    animation: false,
                                    plugins: {
                                        legend: {
                                            display: true,
                                            position: 'bottom'
                                        }
                                    },
                                    scales: {
                                        x: {
                                            title: {
                                                display: true,
                                                text: 'Semanas del Proyecto'
                                            },
                                            ticks: {
                                                callback: function(value) {
                                                    return 'S' + this.getLabelForValue(value);
                                                }
                                            }
                                        },
                                        y: {
                                            title: {
                                                display: true,
                                                text: 'Horas Acumuladas'
                                            },
                                            ticks: {
                                                callback: function(value) {
                                                    return value + 'h';
                                                }
                                            },
                                            beginAtZero: true
                                        }
                                    }
                                }
                            });

                            // Esperar a que se renderice
                            await new Promise(resolve => setTimeout(resolve, 500));
                            
                            const imgData = canvas.toDataURL('image/png', 1.0);
                            pdf.addImage(imgData, 'PNG', landscapeMargin, yPosition, 
                                       landscapePageWidth - 2 * landscapeMargin, 
                                       landscapePageHeight - yPosition - landscapeMargin);

                            basicChart.destroy();
                            console.log('Gr√°fico generado con m√©todo alternativo b√°sico');

                        } catch (fallbackError) {
                            console.error('Error tambi√©n en m√©todo alternativo:', fallbackError);
                            
                            // Mostrar mensaje de error en el PDF
                            pdf.setFontSize(14);
                            pdf.setFont('helvetica', 'normal');
                            pdf.setTextColor(239, 68, 68);
                            const errorMsg = 'Error al generar el gr√°fico de la Curva S';
                            const errorWidth = pdf.getTextWidth(errorMsg);
                            pdf.text(errorMsg, (landscapePageWidth - errorWidth) / 2, yPosition + 50);
                        }
                    }

                    // Agregar pie de p√°gina con informaci√≥n de contacto
                    pdf.setFontSize(10);
                    pdf.setFont('helvetica', 'normal');
                    pdf.setTextColor(107, 114, 128);
                    const footerText = 'gomez.fredy.sap@gmail.com | +57 3203284420 | Sistema PDT Futura';
                    const footerWidth = pdf.getTextWidth(footerText);
                    pdf.text(footerText, (landscapePageWidth - footerWidth) / 2, landscapePageHeight - 15);

                    // ===== GENERAR Y GUARDAR PDF =====
                    // Agregar watermarks a TODAS las p√°ginas existentes antes de guardar
                    const totalPages = pdf.internal.getNumberOfPages();
                    for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                        pdf.setPage(pageNum);
                        // Solo agregar watermark si no es la p√°gina de curva S (que ya tiene uno)
                        const currentPageOrientation = pdf.internal.pageSize.height > pdf.internal.pageSize.width ? 'portrait' : 'landscape';
                        if (!(pageNum === totalPages && currentPageOrientation === 'landscape')) {
                            await addWatermark();
                        }
                    }

                    const fileName = `${data.projectName.replace(/[^a-zA-Z0-9\s]/g, '_').replace(/\s+/g, '_')}_resumen.pdf`;
                    console.log('Guardando PDF con formato mejorado:', fileName);
                    pdf.save(fileName);

                    console.log('PDF generado exitosamente');
                    
                    // Notificar al parent window que el PDF se complet√≥
                    if (window.parent !== window) {
                        window.parent.postMessage({ type: 'pdf-download-complete', fileName: fileName }, '*');
                    }
                    
                    if (button) {
                        button.disabled = false;
                        button.textContent = 'Descargar Resumen en PDF';
                    }

                } catch (error) {
                    console.error('Error al generar PDF:', error);
                    alert('Error al generar el PDF. Por favor, int√©ntalo nuevamente.');
                    
                    if (button) {
                        button.disabled = false;
                        button.textContent = 'Descargar Resumen en PDF';
                    }
                }
            }

            newBtn.addEventListener('click', async () => {
                await generateSimplePDF(data, newBtn);
            });

            // Retornar la funci√≥n generateSimplePDF para uso en auto-download
            return generateSimplePDF;
        }



        // Funci√≥n centralizada para calcular m√©tricas del proyecto
        function calculateProjectMetrics(data) {
            // Calcular estad√≠sticas b√°sicas
            let totalTasks = 0;
            let completedTasks = 0;
            let totalHours = 0;
            let completedHours = 0;

            data.phases.forEach(phase => {
                totalTasks += phase.tasks.length;
                phase.tasks.forEach(task => {
                    totalHours += task.durationHours;
                    if (task.completed) {
                        completedTasks++;
                        completedHours += task.durationHours;
                    }
                });
            });

            // Calcular fechas del proyecto
            const projectStartDate = data.startDate && typeof data.startDate.toDate === 'function' ? data.startDate.toDate() : new Date(data.startDate);
            const lastTask = data.phases[data.phases.length - 1].tasks.slice(-1)[0];
            const projectEndDate = lastTask.endDate && typeof lastTask.endDate.toDate === 'function' ? lastTask.endDate.toDate() : new Date(lastTask.endDate);
            const totalDuration = projectEndDate - projectStartDate;
            const totalWeeks = Math.max(1, Math.ceil(totalDuration / (1000 * 60 * 60 * 24 * 7)));
            const currentWeek = Math.floor((new Date() - projectStartDate) / (1000 * 60 * 60 * 24 * 7));

            // Generar datos de progreso planificado (curva S)
            const plannedProgress = [];
            for (let week = 0; week < totalWeeks; week++) {
                const plannedPercent = week / (totalWeeks - 1);
                const sigmoid = 1 / (1 + Math.exp(-6 * (plannedPercent - 0.5)));
                plannedProgress.push(Math.round(sigmoid * totalHours));
            }

            // Calcular m√©tricas de rendimiento
            let scheduleVariance = 0;
            let schedulePerformanceIndex = 1.0;
            let projectStatus = 'En Tiempo';

            // L√≥gica corregida para todos los escenarios
            if (currentWeek < 0) {
                // Proyecto con fecha de inicio en el futuro
                if (completedHours === 0) {
                    // No hay progreso - proyecto planificado
                    projectStatus = 'Planificado';
                    scheduleVariance = 0;
                    schedulePerformanceIndex = 1.0;
                } else {
                    // Hay progreso completado ANTES de la fecha de inicio - MUY ADELANTE
                    // Esto significa que el proyecto est√° muy adelantado al cronograma
                    // Como el proyecto a√∫n no ha empezado oficialmente, cualquier progreso es 100% adelantado
                    scheduleVariance = 100; // 100% adelantado
                    schedulePerformanceIndex = completedHours > 0 ? 2.0 : 1.0; // Al menos 2.0x el rendimiento esperado
                    projectStatus = 'Muy Adelantado';
                }
            } else {
                // Proyecto ya iniciado (currentWeek >= 0)
                const clampedCurrentWeek = Math.max(0, Math.min(currentWeek, totalWeeks - 1));
                const plannedAtCurrent = plannedProgress[clampedCurrentWeek] || 0;
                const actualAtCurrent = completedHours;

                if (plannedAtCurrent > 0) {
                    scheduleVariance = ((actualAtCurrent - plannedAtCurrent) / plannedAtCurrent * 100);
                    schedulePerformanceIndex = (actualAtCurrent / plannedAtCurrent);
                } else {
                    // Si no se planeaba tener progreso a√∫n, pero hay progreso, est√° adelantado
                    scheduleVariance = actualAtCurrent > 0 ? 100 : 0;
                    schedulePerformanceIndex = actualAtCurrent > 0 ? 2.0 : 1.0;
                }

                // Determinar estado basado en variaci√≥n
                if (scheduleVariance > 10) {
                    projectStatus = 'Muy Adelantado';
                } else if (scheduleVariance > 5) {
                    projectStatus = 'Adelantado';
                } else if (scheduleVariance < -10) {
                    projectStatus = 'Muy Retrasado';
                } else if (scheduleVariance < -5) {
                    projectStatus = 'Atrasado';
                }
            }

            return {
                totalTasks,
                totalHours,
                completedTasks,
                completedHours,
                progressPercentage: totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0,
                scheduleVariance,
                schedulePerformanceIndex,
                projectStatus,
                projectStartDate,
                projectEndDate,
                totalWeeks,
                currentWeek,
                plannedProgress
            };
        }

        // Funci√≥n para configurar el rec√°lculo de fechas - definida antes de renderProject
        function setupDateRecalculation(data) {
            console.log('setupDateRecalculation funci√≥n iniciada correctamente');
            const recalculateBtn = document.getElementById('recalculate-dates-btn');
            
            if (!recalculateBtn) {
                console.log('Bot√≥n de rec√°lculo no encontrado');
                return;
            }
            
            // Limpiar event listeners anteriores para evitar m√∫ltiples llamadas
            const newBtn = recalculateBtn.cloneNode(true);
            recalculateBtn.parentNode.replaceChild(newBtn, recalculateBtn);
            
            // Actualizar el campo project-start-date en tiempo real cuando cambia el input
            const startDateInput = document.getElementById('start-date-input');
            if (startDateInput) {
                startDateInput.addEventListener('change', () => {
                    const selectedDate = createDateFromInput(startDateInput.value);
                    if (selectedDate) {
                        document.getElementById('project-start-date').textContent = formatDateForDisplay(selectedDate);
                    }
                });
            }
            
            // Funci√≥n com√∫n para recalcular fechas y guardar configuraci√≥n
            const recalculateAndSave = async () => {
                const newStartDate = createDateFromInput(startDateInput.value);
                if (!newStartDate) {
                    alert('Por favor, selecciona una fecha de inicio v√°lida.');
                    return;
                }

                console.log('Recalculando fechas desde:', formatDateForDisplay(newStartDate));
                
                // Actualizar datos del proyecto
                data.startDate = newStartDate;
                
                // Recalcular fechas de todas las fases y tareas
                let currentDate = new Date(newStartDate);
                
                data.phases.forEach(phase => {
                    // Calcular fecha de inicio y fin de la fase
                    phase.startDate = new Date(currentDate);
                    
                    let phaseDuration = 0;
                    phase.tasks.forEach(task => {
                        task.startDate = new Date(currentDate);
                        
                        // Sumar duraci√≥n de la tarea
                        const taskDays = Math.ceil((task.durationHours || 0) / 8);
                        currentDate.setDate(currentDate.getDate() + taskDays);
                        task.endDate = new Date(currentDate);
                        
                        phaseDuration += taskDays;
                    });
                    
                    phase.endDate = new Date(currentDate);
                    console.log(`Fase ${phase.name}: ${formatDateForDisplay(phase.startDate)} - ${formatDateForDisplay(phase.endDate)}`);
                });
                
                // Actualizar fechas en la UI
                document.getElementById('project-start-date').textContent = formatDateForDisplay(newStartDate);
                document.getElementById('project-end-date').textContent = formatDateForDisplay(currentDate);
                
                // Actualizar el objeto data local con las nuevas fechas calculadas
                data.startDate = newStartDate;
                data.endDate = currentDate;
                
                // Guardar en Firebase
                try {
                    await db.collection('projects').doc(data.id).update({
                        startDate: newStartDate,
                        endDate: currentDate,
                        phases: data.phases
                    });
                    
                    console.log('Fechas actualizadas y guardadas en Firebase');
                    alert('Fechas recalculadas y guardadas exitosamente');
                    
                    // Regenerar la vista del calendario con los datos actualizados
                    renderCalendar(data);
                    setupCalendarInteractions(data);
                    
                } catch (error) {
                    console.error('Error al guardar fechas:', error);
                    alert('Error al guardar las fechas. Por favor, int√©ntalo nuevamente.');
                }
            };
            
            // Configurar event listener del bot√≥n
            newBtn.addEventListener('click', recalculateAndSave);
        }

        function renderProject(data, autoDownload = null) {
            // --- Renderizar T√≠tulo y Estad√≠sticas ---
            document.getElementById('project-name').textContent = data.projectName;
            let totalTasks = 0;
            let totalHours = 0;
            let completedTasks = 0;
            let completedHours = 0;
            data.phases.forEach(phase => {
                totalTasks += phase.tasks.length;
                phase.tasks.forEach(task => {
                    totalHours += task.durationHours;
                    if (task.completed) {
                        completedTasks++;
                        completedHours += task.durationHours;
                    }
                });
            });
            document.getElementById('total-tasks').textContent = totalTasks;
            document.getElementById('total-hours').textContent = Math.round(totalHours);
            document.getElementById('completed-tasks').textContent = completedTasks;
            document.getElementById('completed-hours').textContent = Math.round(completedHours);
            
            // Calcular y mostrar progreso general
            const progressPercentage = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;
            document.getElementById('overall-progress').style.width = progressPercentage + '%';
            document.getElementById('progress-text').textContent = Math.round(progressPercentage) + '%';

            // --- Renderizar Fechas ---
            const projectStartDate = data.startDate && typeof data.startDate.toDate === 'function' ? data.startDate.toDate() : new Date(data.startDate);

            // Asegurar consistencia: ambos campos deben mostrar la misma fecha formateada
            document.getElementById('project-start-date').textContent = formatDateForDisplay(projectStartDate);
            document.getElementById('start-date-input').valueAsDate = projectStartDate;

            // Cargar configuraci√≥n del proyecto con valores por defecto
            document.getElementById('include-saturdays').checked = data.includeSaturdays !== undefined ? data.includeSaturdays : true;
            document.getElementById('include-sundays').checked = data.includeSundays !== undefined ? data.includeSundays : true;
            document.getElementById('include-holidays').checked = data.includeHolidays !== undefined ? data.includeHolidays : true;
            
            // Cargar configuraci√≥n del turno con valores por defecto
            document.getElementById('shift-start-time').value = data.shiftStartTime || '08:00';
            document.getElementById('shift-end-time').value = data.shiftEndTime || '17:00';
            document.getElementById('shift-break-hours').value = data.shiftBreakHours !== undefined ? data.shiftBreakHours : 1;

            // Calcular y mostrar fechas del proyecto
            const lastTask = data.phases[data.phases.length - 1].tasks.slice(-1)[0];
            const projectEndDate = lastTask.endDate && typeof lastTask.endDate.toDate === 'function' ? lastTask.endDate.toDate() : new Date(lastTask.endDate);
            const durationDays = Math.ceil((projectEndDate - projectStartDate) / (1000 * 60 * 60 * 24));

            document.getElementById('project-end-date').textContent = formatDateForDisplay(projectEndDate);
            document.getElementById('project-duration').textContent = durationDays;
            document.getElementById('project-last-update').textContent = data.lastUpdated && typeof data.lastUpdated.toDate === 'function' ? data.lastUpdated.toDate().toLocaleString() : (data.lastUpdated ? new Date(data.lastUpdated).toLocaleString() : 'N/A');

            // Cargar festivos
            loadHolidays(data.holidays || []);

            // Mostrar/ocultar lista de festivos seg√∫n el checkbox
            toggleHolidaysList();


            // --- Renderizar Fases y Tareas ---
            const phasesContainer = document.getElementById('phases-container');
            phasesContainer.innerHTML = ''; // Limpiar contenido est√°tico
            data.phases.forEach((phase, index) => {
                const phaseEl = document.createElement('div');
                phaseEl.className = 'phase';
                
                let tasksHtml = '';
                phase.tasks.forEach((task, taskIndex) => {
                    const isMilestone = task.isMilestone || task.esHito || false;
                    const isCompleted = task.completed || false;
                    const startTime = task.startTime || '';
                    const endTime = task.endTime || '';
                    tasksHtml +=
                        '<div class="task ' + (isMilestone ? 'milestone' : '') + (isCompleted ? ' completed' : '') + '">' +
                            '<div class="task-content">' +
                                '<div class="task-left">' +
                                    '<input type="checkbox" class="task-checkbox" data-task-index="' + taskIndex + '" data-phase-index="' + index + '" ' + (isCompleted ? 'checked' : '') + '>' +
                                    '<div class="task-name">' + task.name + (isMilestone ? ' üéØ' : '') + '</div>' +
                                '</div>' +
                                '<div class="task-right">' +
                                    '<div class="task-details">' +
                                        '<span class="task-hours">' + task.durationHours + 'h</span>' +
                                    '</div>' +
                                    '<div class="task-times">' +
                                        '<span class="task-time-label">Inicio: ' +
                                            (task.startDate && typeof task.startDate.toDate === 'function' ? task.startDate.toDate().toLocaleDateString() : new Date(task.startDate).toLocaleDateString()) + ' ' +
                                            (startTime || '--:--') +
                                        '</span>' +
                                        '<span class="task-time-label">Fin: ' +
                                            (task.endDate && typeof task.endDate.toDate === 'function' ? task.endDate.toDate().toLocaleDateString() : new Date(task.endDate).toLocaleDateString()) + ' ' +
                                            (endTime || '--:--') +
                                        '</span>' +
                                    '</div>' +
                                '</div>' +
                            '</div>' +
                        '</div>';
                });

                phaseEl.innerHTML = `
                    <div class="phase-header phase${(index % 4) + 1}" data-phase-index="${index}">
                        <div class="phase-number">${index + 1}</div>
                        <div class="phase-title">${phase.name}</div>
                        <div class="phase-toggle">‚ñº</div>
                    </div>
                    <div class="tasks-timeline">${tasksHtml}</div>
                `;
                phasesContainer.appendChild(phaseEl);
            });
            
            // Agregar event listeners para colapsar/expandir fases
            document.querySelectorAll('.phase-header').forEach(header => {
                header.addEventListener('click', (e) => {
                    const phaseEl = header.parentElement;
                    const isCollapsed = phaseEl.classList.contains('collapsed');
                    
                    if (isCollapsed) {
                        phaseEl.classList.remove('collapsed');
                        header.classList.remove('collapsed');
                    } else {
                        phaseEl.classList.add('collapsed');
                        header.classList.add('collapsed');
                    }
                });
                
                // Doble clic para colapsar/expandir todas las fases
                header.addEventListener('dblclick', (e) => {
                    e.preventDefault(); // Prevenir el comportamiento por defecto
                    
                    const allPhases = document.querySelectorAll('.phase');
                    const allCollapsed = Array.from(allPhases).every(phase => phase.classList.contains('collapsed'));
                    
                    if (allCollapsed) {
                        // Expandir todas las fases
                        allPhases.forEach(phase => {
                            phase.classList.remove('collapsed');
                            const header = phase.querySelector('.phase-header');
                            if (header) {
                                header.classList.remove('collapsed');
                            }
                        });
                    } else {
                        // Colapsar todas las fases
                        allPhases.forEach(phase => {
                            phase.classList.add('collapsed');
                            const header = phase.querySelector('.phase-header');
                            if (header) {
                                header.classList.add('collapsed');
                            }
                        });
                    }
                });
            });
            
            // Agregar event listeners a los checkboxes
            document.querySelectorAll('.task-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', async (e) => {
                    const taskIndex = parseInt(e.target.dataset.taskIndex);
                    const phaseIndex = parseInt(e.target.dataset.phaseIndex);
                    const isCompleted = e.target.checked;
                    
                    // Aplicar/remover clase visual inmediatamente
                    const taskElement = e.target.closest('.task');
                    if (isCompleted) {
                        taskElement.classList.add('completed');
                    } else {
                        taskElement.classList.remove('completed');
                    }
                    
                    try {
                        // Actualizar el estado de la tarea en los datos locales
                        if (data.phases[phaseIndex] && data.phases[phaseIndex].tasks[taskIndex]) {
                            data.phases[phaseIndex].tasks[taskIndex].completed = isCompleted;
                            
                            // Si se marca como completada y no tiene fecha de fin, asignar fecha actual
                            if (isCompleted && !data.phases[phaseIndex].tasks[taskIndex].endDate) {
                                data.phases[phaseIndex].tasks[taskIndex].endDate = new Date();
                            }
                        } else {
                            console.error('Task not found at phase', phaseIndex, 'task', taskIndex);
                        }
                        
                        // Guardar el proyecto usando la funci√≥n helper
                        await saveProject(data);
                        
                        // Recalcular y actualizar las estad√≠sticas
                        updateProgressStats(data);
                        
                        // Actualizar calendario y curva S con los nuevos datos
                        renderCalendar(data);
                        setupCalendarInteractions(data);
                        console.log('Actualizando curva S despu√©s de cambio en tarea...');
                        renderSCurve(data);
                        
                    } catch (error) {
                        console.error('Error al actualizar el estado de la tarea:', error);
                        // Revertir el cambio del checkbox en caso de error
                        e.target.checked = !isCompleted;
                        // Revertir tambi√©n la clase visual
                        if (isCompleted) {
                            taskElement.classList.remove('completed');
                        } else {
                            taskElement.classList.add('completed');
                        }
                        alert('Error al guardar el cambio. Int√©ntalo de nuevo.');
                    }
                });
            });
            
            // --- L√≥gica para Gr√°ficos y PDF (se implementar√° despu√©s) ---
            renderCalendar(data);
            setupCalendarInteractions(data);
            renderSCurve(data);
            const generatePDFFunc = setupPdfDownload(data);
            
            // Si se especific√≥ auto-download, descargar el PDF autom√°ticamente
            if (autoDownload === 'pdf') {
                // Esperar m√°s tiempo para que se renderice completamente antes de descargar
                setTimeout(() => {
                    generatePDFFunc(data);
                }, 2000);
            }
            
            // Configurar el bot√≥n de recalcular fechas
            console.log('Verificando setupDateRecalculation...', typeof setupDateRecalculation);
            if (typeof setupDateRecalculation === 'function') {
                setupDateRecalculation(data);
            } else {
                console.error('setupDateRecalculation no est√° definida como funci√≥n');
            }

            // Configurar el bot√≥n de aplicar cambios para usar la l√≥gica avanzada de recalculateDates
            const applyChangesBtn = document.getElementById('recalculate-dates-btn');
            if (applyChangesBtn) {
                // Limpiar event listeners anteriores
                const newBtn = applyChangesBtn.cloneNode(true);
                applyChangesBtn.parentNode.replaceChild(newBtn, applyChangesBtn);

                newBtn.addEventListener('click', async () => {
                    try {
                        console.log('Aplicando cambios con l√≥gica avanzada de recalculateDates...');

                        // Usar la funci√≥n recalculateDates para aplicar todos los cambios
                        const updatedData = await recalculateDates(data);

                        // Guardar el proyecto actualizado usando la funci√≥n helper
                        await saveProject(updatedData);

                        // Actualizar la vista del proyecto con los datos recalculados
                        renderProject(updatedData);

                        console.log('Cambios aplicados y guardados exitosamente');
                        alert('Cambios aplicados y guardados exitosamente. Las fechas han sido recalculadas correctamente.');

                    } catch (error) {
                        console.error('Error al aplicar cambios:', error);
                        alert('Error al aplicar cambios. Por favor, int√©ntalo nuevamente.');
                    }
                });
            }

            // Configurar funcionalidad de festivos
            setupHolidaysFunctionality(data);
            
            // Configurar bot√≥n de volver a proyectos
            setupBackToProjectsFunctionality();
            
            // Configurar bot√≥n de cerrar sesi√≥n
            setupLogoutFunctionality();
        }

        function calculateWorkingDays(startDate, endDate, config) {
            let workingDays = 0;
            const currentDate = new Date(startDate);
            
            while (currentDate <= endDate) {
                const dayOfWeek = currentDate.getDay();
                const isWeekend = (dayOfWeek === 0 && config.includeSundays) || (dayOfWeek === 6 && config.includeSaturdays);
                const isHoliday = config.includeHolidays ? isHolidayDate(currentDate, config.holidays) : false;
                
                if (!isWeekend && !isHoliday) {
                    workingDays++;
                }
                
                currentDate.setDate(currentDate.getDate() + 1);
            }
            
            return workingDays;
        }

        function addWorkingDays(startDate, workingDays, config) {
            const resultDate = new Date(startDate);
            let addedDays = 0;
            
            while (addedDays < workingDays) {
                // Verificar si el d√≠a actual es laborable
                const dayOfWeek = resultDate.getDay();
                const isWeekend = (dayOfWeek === 0 && config.includeSundays) || (dayOfWeek === 6 && config.includeSaturdays);
                const isHoliday = config.includeHolidays ? isHolidayDate(resultDate, config.holidays) : false;
                
                if (!isWeekend && !isHoliday) {
                    addedDays++;
                }
                
                // Si a√∫n necesitamos m√°s d√≠as, avanzar al siguiente d√≠a
                if (addedDays < workingDays) {
                    resultDate.setDate(resultDate.getDate() + 1);
                }
            }
            
            return resultDate;
        }

        function isHolidayDate(date, holidays) {
            const dateStr = date.toISOString().split('T')[0];
            return holidays.some(holiday => {
                const holidayDate = holiday.date && typeof holiday.date.toDate === 'function' ? holiday.date.toDate() : new Date(holiday.date);
                return holidayDate.toISOString().split('T')[0] === dateStr;
            });
        }

        function loadHolidays(holidays) {
            const container = document.getElementById('holidays-container');
            container.innerHTML = '';
            
            holidays.forEach((holiday, index) => {
                const holidayDate = holiday.date && typeof holiday.date.toDate === 'function' ? holiday.date.toDate() : new Date(holiday.date);
                const holidayItem = document.createElement('div');
                holidayItem.className = 'holiday-item';
                holidayItem.innerHTML = `
                    <input type="date" value="${holidayDate.toISOString().split('T')[0]}" data-index="${index}">
                    <input type="text" placeholder="Nombre del festivo" value="${holiday.name || ''}" data-index="${index}">
                    <button type="button" onclick="removeHoliday(${index})">Eliminar</button>
                `;
                container.appendChild(holidayItem);
            });
        }

        function toggleHolidaysList() {
            const includeHolidays = document.getElementById('include-holidays').checked;
            const holidaysList = document.getElementById('holidays-list');
            holidaysList.style.display = includeHolidays ? 'block' : 'none';
        }

        function removeHoliday(index) {
            const container = document.getElementById('holidays-container');
            const holidayItems = container.querySelectorAll('.holiday-item');
            if (holidayItems[index]) {
                holidayItems[index].remove();
            }
        }

        function removeHolidayItem(button) {
            button.parentElement.remove();
        }

        function updateProgressStats(data) {
            let totalTasks = 0;
            let totalHours = 0;
            let completedTasks = 0;
            let completedHours = 0;
            data.phases.forEach(phase => {
                totalTasks += phase.tasks.length;
                phase.tasks.forEach(task => {
                    const taskHours = task.durationHours || task.hours || 0;
                    totalHours += taskHours;
                    if (task.completed) {
                        completedTasks++;
                        completedHours += taskHours;
                    }
                });
            });
            
            document.getElementById('completed-tasks').textContent = completedTasks;
            document.getElementById('completed-hours').textContent = Math.round(completedHours);
            
            const progressPercentage = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;
            document.getElementById('overall-progress').style.width = progressPercentage + '%';
            document.getElementById('progress-text').textContent = Math.round(progressPercentage) + '%';
            
            // Actualizar √∫ltima actualizaci√≥n
            document.getElementById('project-last-update').textContent = data.lastUpdated && typeof data.lastUpdated.toDate === 'function' ? data.lastUpdated.toDate().toLocaleString() : (data.lastUpdated ? new Date(data.lastUpdated).toLocaleString() : 'N/A');

            // Actualizar m√©tricas de rendimiento usando calculateProjectMetrics
            const metrics = calculateProjectMetrics(data);
            const { scheduleVariance, schedulePerformanceIndex, projectStatus } = metrics;

            // Mostrar m√©tricas actualizadas
            if (projectStatus === 'Planificado') {
                document.getElementById('schedule-variance').textContent = 'N/A';
                document.getElementById('performance-index').textContent = 'N/A';
            } else {
                document.getElementById('schedule-variance').textContent =
                    (scheduleVariance >= 0 ? '+' : '') + scheduleVariance.toFixed(1) + '%';
                document.getElementById('performance-index').textContent = schedulePerformanceIndex.toFixed(2);
            }
            document.getElementById('project-status').textContent = projectStatus;
        }

        function renderCalendar(data) {
            const calendarContainer = document.getElementById('calendar-container');

            // Calcular fechas del proyecto
            const projectStart = data.startDate && typeof data.startDate.toDate === 'function' ? data.startDate.toDate() : new Date(data.startDate);
            const lastTask = data.phases[data.phases.length - 1].tasks.slice(-1)[0];
            const projectEnd = lastTask.endDate && typeof lastTask.endDate.toDate === 'function' ? lastTask.endDate.toDate() : new Date(lastTask.endDate);

            // Calcular n√∫mero de meses a mostrar (desde el mes de inicio hasta el mes de fin)
            const startMonth = new Date(projectStart.getFullYear(), projectStart.getMonth(), 1);
            const endMonth = new Date(projectEnd.getFullYear(), projectEnd.getMonth(), 1);
            const monthsDiff = (endMonth.getFullYear() - startMonth.getFullYear()) * 12 + (endMonth.getMonth() - startMonth.getMonth()) + 1;
            const monthsToShow = Math.max(1, Math.min(monthsDiff, 7)); // M√°ximo 7 meses, m√≠nimo 1

            calendarContainer.innerHTML = '';

            // Generar calendarios para los meses calculados
            for (let month = 0; month < monthsToShow; month++) {
                const currentMonth = new Date(startMonth.getFullYear(), startMonth.getMonth() + month, 1);
                const monthContainer = createMonthCalendar(currentMonth, data);
                calendarContainer.appendChild(monthContainer);
            }
            
            // Agregar leyenda
            const legend = document.createElement('div');
            legend.className = 'calendar-legend';
            legend.innerHTML = `
                <div class="legend-calendar-item">
                    <div class="legend-calendar-color legend-task-start"></div>
                    <span>Inicio de Tarea Regular</span>
                </div>
                <div class="legend-calendar-item">
                    <div class="legend-calendar-color legend-milestone-start"></div>
                    <span>Inicio de Hito üéØ</span>
                </div>
                <div class="legend-calendar-item">
                    <div class="legend-calendar-color" style="background: linear-gradient(135deg, #d4edda, #c3e6cb); border: 2px solid #28a745;"></div>
                    <span>Tarea Completada ‚úÖ</span>
                </div>
                <div class="legend-calendar-item">
                    <div class="legend-calendar-color" style="background: linear-gradient(135deg, #f8d7da, #f5c6cb); border: 2px solid #dc3545;"></div>
                    <span>Festivo</span>
                </div>
                <div class="legend-calendar-item">
                    <div class="task-indicator">T#</div>
                    <span>N√∫mero de Tarea</span>
                </div>
                <div class="legend-calendar-item">
                    <div class="milestone-indicator">H#</div>
                    <span>N√∫mero de Hito</span>
                </div>
            `;
            calendarContainer.appendChild(legend);
        }
        
        function createMonthCalendar(date, data) {
            const monthContainer = document.createElement('div');
            monthContainer.className = 'month-container';
            
            const monthName = date.toLocaleDateString('es-ES', { month: 'long', year: 'numeric' });
            const firstDay = new Date(date.getFullYear(), date.getMonth(), 1);
            const lastDay = new Date(date.getFullYear(), date.getMonth() + 1, 0);
            const startDayOfWeek = firstDay.getDay(); // 0 = Domingo, 1 = Lunes, etc.
            
            let calendarHtml = `
                <div class="month-header">${monthName}</div>
                <div class="calendar-grid">
                    <div class="calendar-day-header">L</div>
                    <div class="calendar-day-header">M</div>
                    <div class="calendar-day-header">M</div>
                    <div class="calendar-day-header">J</div>
                    <div class="calendar-day-header">V</div>
                    <div class="calendar-day-header">S</div>
                    <div class="calendar-day-header">D</div>
            `;
            
            // D√≠as vac√≠os al inicio
            for (let i = 0; i < (startDayOfWeek === 0 ? 6 : startDayOfWeek - 1); i++) {
                calendarHtml += '<div class="calendar-day other-month"></div>';
            }
            
            // D√≠as del mes
            for (let day = 1; day <= lastDay.getDate(); day++) {
                const currentDate = new Date(date.getFullYear(), date.getMonth(), day);
                const dayTasks = getTasksForDate(currentDate, data);
                const isToday = currentDate.toDateString() === new Date().toDateString();
                const holidayInfo = getHolidayInfo(currentDate, data.holidays || []);
                
                let dayClass = 'calendar-day';
                if (isToday) dayClass += ' today';
                if (holidayInfo.isHoliday) dayClass += ' holiday';
                
                let dayContent = `<span class="day-number">${day}</span>`;
                
                // Agregar nombre del festivo si es d√≠a festivo
                if (holidayInfo.isHoliday) {
                    dayContent += `<div class="holiday-name">${holidayInfo.name}</div>`;
                }
                
                if (dayTasks.length > 0) {
                    dayClass += ' has-task';
                    if (dayTasks.some(t => t.isMilestone)) dayClass += ' has-milestone';
                    if (dayTasks.some(t => t.completed)) dayClass += ' has-completed-task';
                    
                    // Mostrar indicadores de tareas con tooltips
                    dayTasks.forEach(task => {
                        const taskType = task.isMilestone ? 'milestone' : 'regular';
                        const taskTooltip = `${task.name} (${task.durationHours}h)`;
                        if (task.isMilestone) {
                            dayContent += `<div class="milestone-indicator" data-task-tooltip="${taskTooltip}" data-task-id="${task.number}" data-phase-index="${task.phaseIndex}" data-task-index="${task.taskIndex}">${task.number}</div>`;
                        } else {
                            dayContent += `<div class="task-indicator" data-task-tooltip="${taskTooltip}" data-task-id="${task.number}" data-phase-index="${task.phaseIndex}" data-task-index="${task.taskIndex}">${task.number}</div>`;
                        }
                    });
                }
                
                const tooltip = holidayInfo.isHoliday ? `${currentDate.toLocaleDateString('es-ES')} - ${holidayInfo.name}` : currentDate.toLocaleDateString('es-ES');
                // Crear fecha en formato YYYY-MM-DD sin zona horaria para evitar problemas
                const year = currentDate.getFullYear();
                const month = String(currentDate.getMonth() + 1).padStart(2, '0');
                const dayStr = String(currentDate.getDate()).padStart(2, '0');
                const dateStr = `${year}-${month}-${dayStr}`;
                calendarHtml += `<div class="${dayClass}" data-date="${dateStr}">${dayContent}</div>`;
            }
            
            calendarHtml += '</div>';
            monthContainer.innerHTML = calendarHtml;
            return monthContainer;
        }
        
        function getHolidayInfo(date, holidays) {
            const dateStr = date.toISOString().split('T')[0];
            for (const holiday of holidays) {
                const holidayDate = holiday.date && typeof holiday.date.toDate === 'function' ? holiday.date.toDate() : new Date(holiday.date);
                if (holidayDate.toISOString().split('T')[0] === dateStr) {
                    return { isHoliday: true, name: holiday.name || 'Festivo' };
                }
            }
            return { isHoliday: false, name: '' };
        }

        function renderSCurve(data) {
            console.log('renderSCurve ejecut√°ndose con datos:', {
                totalTasks: data.phases.reduce((sum, p) => sum + p.tasks.length, 0),
                completedTasks: data.phases.reduce((sum, p) => sum + p.tasks.filter(t => t.completed).length, 0),
                totalHours: data.phases.reduce((sum, p) => sum + p.tasks.reduce((s, t) => s + (t.durationHours || 0), 0), 0),
                completedHours: data.phases.reduce((sum, p) => sum + p.tasks.filter(t => t.completed).reduce((s, t) => s + (t.durationHours || 0), 0), 0)
            });
            
            const sCurveContainer = document.getElementById('s-curve-chart');

            // Calcular fechas del proyecto
            const projectStart = data.startDate && typeof data.startDate.toDate === 'function' ? data.startDate.toDate() : new Date(data.startDate);
            const lastTask = data.phases[data.phases.length - 1].tasks.slice(-1)[0];
            const projectEnd = lastTask.endDate && typeof lastTask.endDate.toDate === 'function' ? lastTask.endDate.toDate() : new Date(lastTask.endDate);
            const totalDuration = projectEnd - projectStart;

            // Usar la funci√≥n centralizada calculateProjectMetrics para obtener todas las m√©tricas
            const metrics = calculateProjectMetrics(data);
            const {
                scheduleVariance,
                schedulePerformanceIndex,
                projectStatus,
                totalTasks,
                totalHours,
                completedTasks,
                completedHours,
                totalWeeks,
                currentWeek,
                plannedProgress
            } = metrics;

            // Calcular clampedCurrentWeek usando los valores de calculateProjectMetrics
            const clampedCurrentWeek = Math.max(0, Math.min(metrics.currentWeek, metrics.totalWeeks - 1));

            // Generar datos para la curva S usando los valores de calculateProjectMetrics
            const projectWeeks = [];
            const actualProgress = [];

            // Generar projectWeeks y actualProgress basados en las semanas calculadas
            for (let week = 0; week < totalWeeks; week++) {
                projectWeeks.push(week + 1);

                // Progreso actual basado en tareas completadas hasta esta semana
                // CORRECCI√ìN: El progreso real debe ser acumulado - todas las tareas completadas
                // hasta la fecha actual deben contribuir al progreso en todas las semanas siguientes
                const weekDate = new Date(metrics.projectStartDate.getTime() + week * 7 * 24 * 60 * 60 * 1000);
                let actualHoursAtWeek = 0;
                
                data.phases.forEach(phase => {
                    phase.tasks.forEach(task => {
                        if (task.completed) {
                            // Una tarea completada contribuye a todo el progreso desde su fecha de finalizaci√≥n
                            // hasta el final del proyecto
                            const taskEndDate = task.endDate && typeof task.endDate.toDate === 'function' ? task.endDate.toDate() : new Date(task.endDate);
                            if (taskEndDate <= weekDate) {
                                actualHoursAtWeek += task.durationHours;
                            }
                        }
                    });
                });
                actualProgress.push(Math.round(actualHoursAtWeek));
            }

            // Mostrar m√©tricas usando los valores de calculateProjectMetrics
            if (projectStatus === 'Planificado') {
                document.getElementById('schedule-variance').textContent = 'N/A';
                document.getElementById('performance-index').textContent = 'N/A';
            } else {
                document.getElementById('schedule-variance').textContent =
                    (scheduleVariance >= 0 ? '+' : '') + scheduleVariance.toFixed(1) + '%';
                document.getElementById('performance-index').textContent = schedulePerformanceIndex.toFixed(2);
            }
            document.getElementById('project-status').textContent = projectStatus;

            // Crear gr√°fico con Chart.js mejorado est√©ticamente
            // Crear canvas si no existe
            let canvas = sCurveContainer.querySelector('canvas');
            if (!canvas) {
                canvas = document.createElement('canvas');
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                // Establecer atributos width y height para Chart.js
                canvas.width = sCurveContainer.offsetWidth || 800;
                canvas.height = sCurveContainer.offsetHeight || 500;
                sCurveContainer.appendChild(canvas);
            }

            const ctx = canvas.getContext('2d');

            // Si el gr√°fico ya existe, actualizarlo en lugar de destruirlo
            if (window.sCurveChart) {
                console.log('Actualizando gr√°fico S-curve existente...');
                // Actualizar los datos del gr√°fico existente
                const metrics = calculateProjectMetrics(data);
                const {
                    scheduleVariance,
                    schedulePerformanceIndex,
                    projectStatus,
                    totalTasks,
                    totalHours,
                    completedTasks,
                    completedHours,
                    totalWeeks,
                    currentWeek,
                    plannedProgress
                } = metrics;

                const clampedCurrentWeek = Math.max(0, Math.min(metrics.currentWeek, metrics.totalWeeks - 1));

                // Generar datos para la curva S
                const projectWeeks = [];
                const actualProgress = [];

                for (let week = 0; week < totalWeeks; week++) {
                    projectWeeks.push(week + 1);
                    let actualHoursAtWeek = 0;
                    const weekDate = new Date(metrics.projectStartDate.getTime() + week * 7 * 24 * 60 * 60 * 1000);
                    data.phases.forEach(phase => {
                        phase.tasks.forEach(task => {
                            if (task.completed) {
                                // CORRECCI√ìN: Una tarea completada contribuye a todo el progreso 
                                // desde su fecha de finalizaci√≥n hasta el final del proyecto
                                const taskEndDate = task.endDate && typeof task.endDate.toDate === 'function' ? task.endDate.toDate() : new Date(task.endDate);
                                if (taskEndDate <= weekDate) {
                                    actualHoursAtWeek += task.durationHours;
                                }
                            }
                        });
                    });
                    actualProgress.push(Math.round(actualHoursAtWeek));
                }

                // Puntos de milestones
                const milestonePoints = [];
                for (let percent = 25; percent <= 100; percent += 25) {
                    const targetHours = (percent / 100) * totalHours;
                    let closestIndex = 0;
                    let minDiff = Math.abs(plannedProgress[0] - targetHours);
                    for (let i = 1; i < plannedProgress.length; i++) {
                        const diff = Math.abs(plannedProgress[i] - targetHours);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestIndex = i;
                        }
                    }
                    milestonePoints.push({
                        x: projectWeeks[closestIndex],
                        y: plannedProgress[closestIndex],
                        label: percent + '%'
                    });
                }

                const currentPoint = completedHours > 0 ? [{
                    x: projectWeeks[clampedCurrentWeek],
                    y: completedHours,
                    label: 'ACTUAL'
                }] : [];

                // Actualizar datasets
                window.sCurveChart.data.labels = projectWeeks;
                window.sCurveChart.data.datasets[0].data = plannedProgress;
                window.sCurveChart.data.datasets[1].data = actualProgress;
                window.sCurveChart.data.datasets[2].data = milestonePoints.map(p => ({ x: p.x, y: p.y }));
                window.sCurveChart.data.datasets[3].data = currentPoint.map(p => ({ x: p.x, y: p.y }));

                // Actualizar m√©tricas en la UI
                if (projectStatus === 'Planificado') {
                    document.getElementById('schedule-variance').textContent = 'N/A';
                    document.getElementById('performance-index').textContent = 'N/A';
                } else {
                    document.getElementById('schedule-variance').textContent =
                        (scheduleVariance >= 0 ? '+' : '') + scheduleVariance.toFixed(1) + '%';
                    document.getElementById('performance-index').textContent = schedulePerformanceIndex.toFixed(2);
                }
                document.getElementById('project-status').textContent = projectStatus;

                // Actualizar el gr√°fico
                window.sCurveChart.update();
                console.log('Gr√°fico S-curve actualizado exitosamente');
                return;
            }

            // Destruir gr√°fico anterior si existe (solo para el caso inicial)
            if (window.sCurveChart) {
                window.sCurveChart.destroy();
                // Limpiar el contenedor
                const sCurveContainer = document.getElementById('s-curve-chart');
                sCurveContainer.innerHTML = '';
            }

            // CORRECCI√ìN: Puntos de referencia para milestones (25%, 50%, 75%, 100%)
            const milestonePoints = [];
            for (let percent = 25; percent <= 100; percent += 25) {
                const targetHours = (percent / 100) * totalHours;
                let closestIndex = 0;
                let minDiff = Math.abs(plannedProgress[0] - targetHours);

                for (let i = 1; i < plannedProgress.length; i++) {
                    const diff = Math.abs(plannedProgress[i] - targetHours);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestIndex = i;
                    }
                }

                milestonePoints.push({
                    x: projectWeeks[closestIndex],
                    y: plannedProgress[closestIndex],
                    label: percent + '%'
                });
            }

            // CORRECCI√ìN: Punto actual con l√≥gica correcta
            const currentPoint = completedHours > 0 ? [{
                x: projectWeeks[clampedCurrentWeek],
                y: completedHours,
                label: 'ACTUAL'
            }] : [];

            // Configurar animaci√≥n inicial desactivada
            let animationEnabled = false;

            try {
                window.sCurveChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: projectWeeks,
                    datasets: [
                        {
                            label: 'Progreso Planificado',
                            data: plannedProgress,
                            borderColor: '#2563eb', // Azul m√°s profesional
                            backgroundColor: 'rgba(37, 99, 235, 0.08)',
                            borderWidth: 3, // L√≠nea m√°s gruesa
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0,
                            pointHoverRadius: 6,
                            pointBackgroundColor: '#2563eb',
                            pointBorderColor: '#ffffff',
                            pointBorderWidth: 2
                        },
                        {
                            label: 'Progreso Real',
                            data: actualProgress,
                            borderColor: '#16a34a', // Verde m√°s profesional
                            backgroundColor: 'rgba(22, 163, 74, 0.08)',
                            borderWidth: 3, // L√≠nea m√°s gruesa
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0,
                            pointHoverRadius: 6,
                            pointBackgroundColor: '#16a34a',
                            pointBorderColor: '#ffffff',
                            pointBorderWidth: 2
                        },
                        {
                            label: 'Hitos del Proyecto',
                            data: milestonePoints.map(p => ({ x: p.x, y: p.y })),
                            borderColor: 'rgba(107, 114, 128, 0.6)',
                            backgroundColor: '#2563eb',
                            borderWidth: 2,
                            borderDash: [6, 4], // Mejor patr√≥n de l√≠nea punteada
                            fill: false,
                            pointRadius: 6, // Puntos m√°s peque√±os y consistentes
                            pointHoverRadius: 8, // Hover m√°s peque√±o
                            pointBackgroundColor: '#2563eb',
                            pointBorderColor: '#ffffff',
                            pointBorderWidth: 2, // Borde m√°s delgado
                            showLine: false
                        },
                        {
                            label: 'Punto Actual',
                            data: currentPoint.map(p => ({ x: p.x, y: p.y })),
                            borderColor: '#dc2626', // Rojo m√°s profesional
                            backgroundColor: '#dc2626',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 6, // Punto m√°s discreto
                            pointHoverRadius: 8, // Hover m√°s peque√±o
                            pointBackgroundColor: '#dc2626',
                            pointBorderColor: '#ffffff',
                            pointBorderWidth: 2, // Borde m√°s delgado
                            showLine: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Curva S - Seguimiento del Progreso del Proyecto',
                            font: {
                                size: 20, // T√≠tulo m√°s grande
                                weight: 'bold',
                                family: 'Segoe UI, system-ui, sans-serif' // Mejor tipograf√≠a
                            },
                            padding: {
                                top: 15,
                                bottom: 20
                            },
                            color: '#1f2937' // Color m√°s oscuro
                        },
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 30,
                                font: {
                                    size: 14,
                                    family: 'Segoe UI, system-ui, sans-serif',
                                    weight: '500'
                                },
                                color: '#1f2937'
                            }
                        },
                        tooltip: {
                            enabled: true,
                            backgroundColor: 'rgba(0,0,0,0.9)',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: 'rgba(255,255,255,0.2)',
                            borderWidth: 1,
                            cornerRadius: 10,
                            displayColors: true,
                            padding: 14,
                            titleFont: {
                                size: 15,
                                weight: 'bold',
                                family: 'Segoe UI, system-ui, sans-serif'
                            },
                            bodyFont: {
                                size: 14,
                                family: 'Segoe UI, system-ui, sans-serif'
                            },
                            callbacks: {
                                title: function(context) {
                                    const weekNumber = context[0].label;
                                    const weekIndex = parseInt(weekNumber) - 1;
                                    const weekDate = new Date(metrics.projectStartDate.getTime() + weekIndex * 7 * 24 * 60 * 60 * 1000);
                                    return 'Semana ' + weekNumber + ' (' + weekDate.toLocaleDateString('es-ES', { month: 'short', day: 'numeric' }) + ')';
                                },
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    label += context.parsed.y + ' horas';
                                    
                                    // Informaci√≥n adicional espec√≠fica por dataset
                                    if (context.datasetIndex === 0) { // Progreso Planificado
                                        const plannedPercent = Math.round((context.parsed.y / totalHours) * 100);
                                        label += ' (' + plannedPercent + '% planificado)';
                                    } else if (context.datasetIndex === 1) { // Progreso Real
                                        const actualPercent = Math.round((context.parsed.y / totalHours) * 100);
                                        label += ' (' + actualPercent + '% completado)';
                                    } else if (context.datasetIndex === 2) { // Hitos
                                        const milestoneIndex = context.dataIndex;
                                        if (milestonePoints[milestoneIndex]) {
                                            label += ' - ' + milestonePoints[milestoneIndex].label + ' del proyecto';
                                        }
                                    } else if (context.datasetIndex === 3) { // Punto actual
                                        const currentPercent = Math.round((completedHours / totalHours) * 100);
                                        label += ' - Estado actual del proyecto (' + currentPercent + '% completado)';
                                    }

                                    return label;
                                },
                                afterLabel: function(context) {
                                    // Informaci√≥n adicional despu√©s de la etiqueta principal
                                    if (context.datasetIndex === 3) { // Punto actual
                                        const variance = metrics.scheduleVariance;
                                        const spi = metrics.schedulePerformanceIndex;
                                        const status = metrics.projectStatus;
                                        
                                        let additionalInfo = [];
                                        if (status !== 'Planificado') {
                                            additionalInfo.push('Variaci√≥n: ' + (variance >= 0 ? '+' : '') + variance.toFixed(1) + '%');
                                            additionalInfo.push('SPI: ' + spi.toFixed(2));
                                        }
                                        additionalInfo.push('Estado: ' + status);
                                        
                                        return additionalInfo;
                                    }
                                    return null;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Semanas del Proyecto',
                                font: {
                                    size: 16,
                                    weight: 'bold',
                                    family: 'Segoe UI, system-ui, sans-serif'
                                },
                                color: '#1f2937'
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0,0,0,0.06)',
                                lineWidth: 1
                            },
                            ticks: {
                                maxTicksLimit: 12,
                                font: {
                                    size: 13,
                                    family: 'Segoe UI, system-ui, sans-serif',
                                    weight: '500'
                                },
                                color: '#374151',
                                callback: function(value, index) {
                                    return 'S' + this.getLabelForValue(value);
                                }
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Horas Acumuladas',
                                font: {
                                    size: 16,
                                    weight: 'bold',
                                    family: 'Segoe UI, system-ui, sans-serif'
                                },
                                color: '#1f2937'
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0,0,0,0.06)',
                                lineWidth: 1
                            },
                            ticks: {
                                font: {
                                    size: 13,
                                    family: 'Segoe UI, system-ui, sans-serif',
                                    weight: '500'
                                },
                                color: '#374151',
                                callback: function(value) {
                                    return value + 'h';
                                }
                            },
                            beginAtZero: true
                        }
                    },
                    elements: {
                        point: {
                            hoverRadius: 8,
                            hoverBorderWidth: 3
                        },
                        line: {
                            borderCapStyle: 'round',
                            borderJoinStyle: 'round'
                        }
                    },
                    animation: {
                        duration: animationEnabled ? 2000 : 0, // Animaci√≥n solo cuando est√° habilitada
                        easing: 'easeInOutQuart',
                        delay: animationEnabled ? function(context) {
                            return context.dataIndex * 80; // Delay m√°s gradual cuando anima
                        } : 0
                    }
                },
                plugins: [{
                    id: 'customLabels',
                    afterDraw: function(chart) {
                        const ctx = chart.ctx;
                        ctx.save();

                        // Dibujar etiquetas para progreso planificado (debajo de la l√≠nea) - M√°s frecuentes y discretas
                        const plannedDataset = chart.getDatasetMeta(0);
                        if (plannedDataset.data.length > 0) {
                            // Mostrar etiquetas cada 4 semanas para mejor legibilidad (menos frecuentes)
                            for (let i = 0; i < plannedDataset.data.length; i += 4) {
                                const dataPoint = plannedDataset.data[i];
                                if (dataPoint) {
                                    const x = dataPoint.x;
                                    const y = dataPoint.y + 20; // M√°s espacio debajo para evitar superposici√≥n
                                    ctx.fillStyle = '#2563eb';
                                    ctx.font = '11px Segoe UI, system-ui, sans-serif';
                                    ctx.textAlign = 'center';
                                    ctx.fillText(plannedProgress[i] + 'h', x, y);
                                }
                            }
                            
                            // Agregar puntos de referencia clave (inicio, medio, fin) - M√°s peque√±os
                            const keyPoints = [0, Math.floor(plannedProgress.length / 2), plannedProgress.length - 1];
                            keyPoints.forEach(index => {
                                if (index < plannedDataset.data.length) {
                                    const dataPoint = plannedDataset.data[index];
                                    if (dataPoint) {
                                        const x = dataPoint.x;
                                        const y = dataPoint.y;
                                        
                                        // Dibujar un peque√±o c√≠rculo en el punto
                                        ctx.fillStyle = '#2563eb';
                                        ctx.beginPath();
                                        ctx.arc(x, y, 2, 0, 2 * Math.PI);
                                        ctx.fill();
                                        
                                        // Borde blanco
                                        ctx.strokeStyle = '#ffffff';
                                        ctx.lineWidth = 1;
                                        ctx.stroke();
                                    }
                                }
                            });
                        }

                        // Dibujar etiquetas para progreso real (encima de la l√≠nea) - M√°s frecuentes y discretas
                        const actualDataset = chart.getDatasetMeta(1);
                        if (actualDataset.data.length > 0) {
                            // Mostrar etiquetas cada 3 semanas si hay progreso
                            for (let i = 0; i < actualDataset.data.length; i += 3) {
                                const dataPoint = actualDataset.data[i];
                                if (dataPoint && actualProgress[i] > 0) { // Solo mostrar si hay progreso
                                    const x = dataPoint.x;
                                    const y = dataPoint.y - 20; // M√°s espacio encima para evitar superposici√≥n
                                    ctx.fillStyle = '#16a34a';
                                    ctx.font = '11px Segoe UI, system-ui, sans-serif';
                                    ctx.textAlign = 'center';
                                    ctx.fillText(actualProgress[i] + 'h', x, y);
                                }
                            }
                            
                            // Agregar puntos de referencia para progreso real - M√°s peque√±os
                            for (let i = 0; i < actualProgress.length; i++) {
                                if (actualProgress[i] > 0) {
                                    const dataPoint = actualDataset.data[i];
                                    if (dataPoint) {
                                        const x = dataPoint.x;
                                        const y = dataPoint.y;
                                        
                                        // Dibujar un peque√±o c√≠rculo verde en puntos con progreso
                                        ctx.fillStyle = '#16a34a';
                                        ctx.beginPath();
                                        ctx.arc(x, y, 1.5, 0, 2 * Math.PI);
                                        ctx.fill();
                                        
                                        // Borde blanco
                                        ctx.strokeStyle = '#ffffff';
                                        ctx.lineWidth = 1;
                                        ctx.stroke();
                                    }
                                }
                            }
                        }

                        // Dibujar etiquetas personalizadas para milestones (25%, 50%, 75%, 100%) - Fuentes reducidas
                        milestonePoints.forEach((point, index) => {
                            const meta = chart.getDatasetMeta(2);
                            const dataPoint = meta.data[index];
                            if (dataPoint) {
                                const x = dataPoint.x;
                                // Posicionar arriba de la curva para evitar superposici√≥n
                                const y = dataPoint.y - 35;
                                ctx.fillStyle = '#1f2937';
                                ctx.font = '12px Segoe UI, system-ui, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText(point.label, x, y);
                                ctx.fillStyle = '#2563eb';
                                ctx.font = '11px Segoe UI, system-ui, sans-serif';
                                ctx.fillText(Math.round(point.y) + 'h', x, y + 15);
                            }
                        });

                        // Dibujar etiqueta para punto actual - Muy discreta
                        if (currentPoint.length > 0) {
                            const meta = chart.getDatasetMeta(3);
                            const dataPoint = meta.data[0];
                            if (dataPoint) {
                                const x = dataPoint.x;
                                // Posicionar arriba del punto para evitar superposici√≥n con la curva
                                const y = dataPoint.y - 20;
                                
                                // Solo mostrar el porcentaje completado de manera discreta
                                const currentPercent = Math.round((completedHours / totalHours) * 100);
                                ctx.fillStyle = '#dc2626';
                                ctx.font = '11px Segoe UI, system-ui, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText(currentPercent + '%', x, y);
                            }
                        }

                        ctx.restore();
                    }
                }]
            });
            } catch (error) {
                console.error('Error al crear el gr√°fico S-curve:', error);
                // Mostrar mensaje de error al usuario
                const sCurveContainer = document.getElementById('s-curve-chart');
                sCurveContainer.innerHTML = '<div style="color: red; text-align: center; padding: 20px;">Error al cargar el gr√°fico. Por favor, recargue la p√°gina.</div>';
            }
            
            // Configurar Intersection Observer para animar cuando entra en el viewport
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && !animationEnabled) {
                        animationEnabled = true;
                        // Actualizar las opciones de animaci√≥n y re-renderizar
                        window.sCurveChart.options.animation = {
                            duration: 2000,
                            easing: 'easeInOutQuart',
                            delay: function(context) {
                                return context.dataIndex * 80;
                            }
                        };
                        window.sCurveChart.update();
                    }
                });
            }, {
                threshold: 0.3, // Activar cuando el 30% del elemento es visible
                rootMargin: '0px 0px -50px 0px' // Margen para activar antes de que llegue completamente
            });

            // Observar el contenedor del gr√°fico
            observer.observe(sCurveContainer);
        }

        function drawPDFSCurve(canvas, data) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Configuraci√≥n de espacio similar a Chart.js para mejor proporci√≥n
            const padding = 60; // M√°s padding para mejor apariencia
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding - 80; // Menos espacio para t√≠tulo, subt√≠tulo y leyenda para m√°s altura del gr√°fico

            // Fondo transparente para ver el logo
            // ctx.fillStyle = '#ffffff';
            // ctx.fillRect(0, 0, width, height);

            // Configurar estilos de alta calidad como Chart.js
            ctx.font = '14px Segoe UI, system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Usar la funci√≥n centralizada calculateProjectMetrics para obtener todas las m√©tricas
            const metrics = calculateProjectMetrics(data);
            const {
                scheduleVariance,
                schedulePerformanceIndex,
                projectStatus,
                totalTasks,
                totalHours,
                completedTasks,
                completedHours,
                plannedProgress,
                totalWeeks,
                currentWeek
            } = metrics;

            const clampedCurrentWeek = Math.max(0, Math.min(metrics.currentWeek, metrics.totalWeeks - 1));

            // Generar datos para la curva S usando la misma l√≥gica que renderSCurve
            const projectWeeks = [];
            const actualProgress = [];

            for (let week = 0; week < totalWeeks; week++) {
                projectWeeks.push(week + 1);

                // Progreso actual basado en tareas completadas hasta esta semana
                // CORRECCI√ìN: El progreso real debe ser acumulado - todas las tareas completadas
                // hasta la fecha actual deben contribuir al progreso en todas las semanas siguientes
                let actualHoursAtWeek = 0;
                const weekDate = new Date(metrics.projectStartDate.getTime() + week * 7 * 24 * 60 * 60 * 1000);
                data.phases.forEach(phase => {
                    phase.tasks.forEach(task => {
                        if (task.completed) {
                            // Una tarea completada contribuye a todo el progreso desde su fecha de finalizaci√≥n
                            // hasta el final del proyecto
                            const taskEndDate = task.endDate && typeof task.endDate.toDate === 'function' ? task.endDate.toDate() : new Date(task.endDate);
                            if (taskEndDate <= weekDate) {
                                actualHoursAtWeek += task.durationHours;
                            }
                        }
                    });
                });
                actualProgress.push(Math.round(actualHoursAtWeek));
            }

            // Puntos de milestones (igual que renderSCurve)
            const milestonePoints = [];
            for (let percent = 25; percent <= 100; percent += 25) {
                const targetHours = (percent / 100) * totalHours;
                let closestIndex = 0;
                let minDiff = Math.abs(plannedProgress[0] - targetHours);

                for (let i = 1; i < plannedProgress.length; i++) {
                    const diff = Math.abs(plannedProgress[i] - targetHours);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestIndex = i;
                    }
                }

                milestonePoints.push({
                    x: projectWeeks[closestIndex],
                    y: plannedProgress[closestIndex],
                    label: percent + '%'
                });
            }

            // Punto actual (igual que renderSCurve)
            const currentPoint = completedHours > 0 ? [{
                x: projectWeeks[clampedCurrentWeek],
                y: completedHours,
                label: 'ACTUAL'
            }] : [];

            // Dibujar grid sutil como Chart.js
            ctx.strokeStyle = 'rgba(0,0,0,0.06)';
            ctx.lineWidth = 1;

            // Grid vertical
            for (let i = 0; i <= 10; i++) {
                const x = padding + (i * chartWidth / 10);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, padding + chartHeight);
                ctx.stroke();
            }

            // Grid horizontal
            for (let i = 0; i <= 10; i++) {
                const y = padding + chartHeight - (i * chartHeight / 10);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + chartWidth, y);
                ctx.stroke();
            }

            // Ejes principales con estilo Chart.js
            ctx.strokeStyle = '#1f2937';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding + chartHeight);
            ctx.lineTo(padding + chartWidth, padding + chartHeight);
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + chartHeight);
            ctx.stroke();

            // Etiquetas del eje Y (Horas) - Estilo Chart.js
            ctx.fillStyle = '#374151';
            ctx.textAlign = 'right';
            ctx.font = '13px Segoe UI, system-ui, sans-serif';
            for (let i = 0; i <= 10; i++) {
                const y = padding + chartHeight - (i * chartHeight / 10);
                const value = Math.round((i * totalHours / 10));
                ctx.fillText(value + 'h', padding - 15, y + 6);
            }

            // Etiquetas del eje X (Semanas) - Mejoradas para legibilidad
            ctx.textAlign = 'center';
            ctx.font = '13px Segoe UI, system-ui, sans-serif';
            ctx.fillStyle = '#374151';
            for (let i = 0; i < projectWeeks.length; i += Math.ceil(projectWeeks.length / 12)) { // M√°s etiquetas
                const x = padding + (i * chartWidth / (projectWeeks.length - 1));
                ctx.fillText('S' + projectWeeks[i], x, padding + chartHeight + 15); // Ajustar posici√≥n para evitar superposici√≥n con leyenda
            }

            // Dibujar curva planificada con estilo Chart.js
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < plannedProgress.length; i++) {
                const x = padding + (i * chartWidth / (plannedProgress.length - 1));
                const y = padding + chartHeight - (plannedProgress[i] * chartHeight / totalHours);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // Dibujar curva real con estilo Chart.js
            ctx.strokeStyle = '#16a34a';
            ctx.lineWidth = 3;
            ctx.beginPath();
            let lastActualIndex = 0;
            for (let i = 0; i < actualProgress.length; i++) {
                if (actualProgress[i] > 0) {
                    lastActualIndex = i;
                }
                const x = padding + (i * chartWidth / (actualProgress.length - 1));
                const y = padding + chartHeight - (actualProgress[i] * chartHeight / totalHours);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // Dibujar puntos de milestones con estilo Chart.js
            milestonePoints.forEach((point, index) => {
                const x = padding + ((point.x - 1) * chartWidth / (projectWeeks.length - 1));
                const y = padding + chartHeight - (point.y * chartHeight / totalHours);

                // Punto con borde blanco
                ctx.fillStyle = '#2563eb';
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fill();

                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Dibujar punto actual con estilo Chart.js
            if (currentPoint.length > 0) {
                const point = currentPoint[0];
                const x = padding + ((point.x - 1) * chartWidth / (projectWeeks.length - 1));
                const y = padding + chartHeight - (point.y * chartHeight / totalHours);

                // Punto con borde blanco
                ctx.fillStyle = '#dc2626';
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fill();

                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Plugin personalizado similar al de Chart.js para etiquetas
            ctx.save();

            // Etiquetas para progreso planificado (debajo de la l√≠nea) - Similar a Chart.js
            for (let i = 0; i < plannedProgress.length; i += 4) {
                const x = padding + (i * chartWidth / (plannedProgress.length - 1));
                const y = padding + chartHeight - (plannedProgress[i] * chartHeight / totalHours) + 25; // M√°s espacio debajo
                ctx.fillStyle = '#2563eb';
                ctx.font = '11px Segoe UI, system-ui, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(plannedProgress[i] + 'h', x, y);
            }

            // Puntos clave del planificado
            const keyPoints = [0, Math.floor(plannedProgress.length / 2), plannedProgress.length - 1];
            keyPoints.forEach(index => {
                if (index < plannedProgress.length) {
                    const x = padding + (index * chartWidth / (plannedProgress.length - 1));
                    const y = padding + chartHeight - (plannedProgress[index] * chartHeight / totalHours);

                    ctx.fillStyle = '#2563eb';
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });

            // Etiquetas para progreso real (encima de la l√≠nea) - Similar a Chart.js
            for (let i = 0; i < actualProgress.length; i += 3) {
                if (actualProgress[i] > 0) {
                    const x = padding + (i * chartWidth / (actualProgress.length - 1));
                    const y = padding + chartHeight - (actualProgress[i] * chartHeight / totalHours) - 25; // M√°s espacio encima
                    ctx.fillStyle = '#16a34a';
                    ctx.font = '11px Segoe UI, system-ui, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(actualProgress[i] + 'h', x, y);
                }
            }

            // Puntos para progreso real
            for (let i = 0; i < actualProgress.length; i++) {
                if (actualProgress[i] > 0) {
                    const x = padding + (i * chartWidth / (actualProgress.length - 1));
                    const y = padding + chartHeight - (actualProgress[i] * chartHeight / totalHours);

                    ctx.fillStyle = '#16a34a';
                    ctx.beginPath();
                    ctx.arc(x, y, 1.5, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            // Etiquetas para milestones - Similar a Chart.js
            milestonePoints.forEach((point, index) => {
                const x = padding + ((point.x - 1) * chartWidth / (projectWeeks.length - 1));
                const y = padding + chartHeight - (point.y * chartHeight / totalHours) - 45; // M√°s espacio arriba para milestones
                ctx.fillStyle = '#1f2937';
                ctx.font = '12px Segoe UI, system-ui, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(point.label, x, y);
                ctx.fillStyle = '#2563eb';
                ctx.font = '11px Segoe UI, system-ui, sans-serif';
                ctx.fillText(Math.round(point.y) + 'h', x, y + 15);
            });

            // Etiqueta para punto actual - Similar a Chart.js
            if (currentPoint.length > 0) {
                const point = currentPoint[0];
                const x = padding + ((point.x - 1) * chartWidth / (projectWeeks.length - 1));
                const y = padding + chartHeight - (point.y * chartHeight / totalHours) - 30; // M√°s espacio arriba para punto actual

                const currentPercent = Math.round((completedHours / totalHours) * 100);
                ctx.fillStyle = '#dc2626';
                ctx.font = '11px Segoe UI, system-ui, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(currentPercent + '%', x, y);
            }

            ctx.restore();

            // Leyenda mejorada estilo Chart.js
            const legendY = height - 40; // Mover la leyenda m√°s arriba para dar m√°s espacio al gr√°fico
            const legendItems = [
                { color: '#2563eb', label: 'Progreso Planificado' },
                { color: '#16a34a', label: 'Progreso Real' },
                { color: '#dc2626', label: 'Punto Actual' }
            ];

            const legendStartX = padding;
            const columnWidth = chartWidth / 3;

            legendItems.forEach((item, index) => {
                const x = legendStartX + (index * columnWidth) + (columnWidth / 2);
                const y = legendY;

                // S√≠mbolos estilo Chart.js
                if (item.color !== '#dc2626') {
                    ctx.strokeStyle = item.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x - 20, y);
                    ctx.lineTo(x + 20, y);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = item.color;
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                ctx.fillStyle = '#1f2937';
                ctx.font = '14px Segoe UI, system-ui, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(item.label, x, y + 25);
            });

            // T√≠tulo estilo Chart.js
            ctx.fillStyle = '#1f2937';
            ctx.font = 'bold 20px Segoe UI, system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Curva S - Seguimiento del Progreso del Proyecto', width / 2, 30);

            // Subt√≠tulo con informaci√≥n completa estilo Chart.js
            ctx.fillStyle = '#4b5563';
            ctx.font = '14px Segoe UI, system-ui, sans-serif';
            const progressPercent = Math.round((completedHours/totalHours)*100);
            const varianceText = projectStatus === 'Planificado' ? 'N/A' :
                (scheduleVariance >= 0 ? '+' + scheduleVariance.toFixed(1) + '%' : scheduleVariance.toFixed(1) + '%');
            const spiText = projectStatus === 'Planificado' ? 'N/A' : schedulePerformanceIndex.toFixed(2);

            ctx.fillText(`${completedTasks}/${totalTasks} tareas completadas ‚Ä¢ ${completedHours}/${totalHours} horas ‚Ä¢ ${progressPercent}% progreso`, width / 2, 45);
            ctx.fillText(`Estado: ${projectStatus} ‚Ä¢ Variaci√≥n: ${varianceText} ‚Ä¢ SPI: ${spiText}`, width / 2, 65);

            // T√≠tulos de ejes estilo Chart.js
            ctx.fillStyle = '#1f2937';
            ctx.font = 'bold 16px Segoe UI, system-ui, sans-serif';

            // T√≠tulo eje Y
            ctx.save();
            ctx.translate(20, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Horas Acumuladas', 0, 0);
            ctx.restore();

            // T√≠tulo eje X
            ctx.textAlign = 'center';
            ctx.fillText('Semanas del Proyecto', width / 2, padding + chartHeight + 20);
        }
    </script>

    <script>
        // Funcionalidad del bot√≥n flotante de navegaci√≥n
        document.addEventListener('DOMContentLoaded', function() {
            const navBtn = document.getElementById('floatingNavBtn');
            const navMenu = document.getElementById('floatingNavMenu');
            
            if (navBtn && navMenu) {
                navBtn.addEventListener('click', function(e) {
                    navMenu.style.display = navMenu.style.display === 'block' ? 'none' : 'block';
                });
                
                // Cerrar men√∫ al hacer click fuera
                document.addEventListener('click', function(e) {
                    if (!navBtn.contains(e.target)) {
                        navMenu.style.display = 'none';
                    }
                });
                
                // Scroll suave al hacer clic en los enlaces
                navMenu.querySelectorAll('a').forEach(function(link) {
                    link.addEventListener('click', function(e) {
                        e.preventDefault();
                        const target = document.querySelector(this.getAttribute('href'));
                        if (target) {
                            target.scrollIntoView({ behavior: 'smooth' });
                            navMenu.style.display = 'none';
                        }
                    });
                });
            }
        });
    </script>
</body>
</html>